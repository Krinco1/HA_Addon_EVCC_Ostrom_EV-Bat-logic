---
phase: 05-dynamic-buffer
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - evcc-smartload/rootfs/app/dynamic_buffer.py
  - evcc-smartload/rootfs/app/main.py
  - evcc-smartload/rootfs/app/state_store.py
autonomous: true
requirements: [PLAN-03]

must_haves:
  truths:
    - "DynamicBufferCalc computes a target buffer SoC every 15-minute cycle based on PV confidence, price spread, and time of day"
    - "In observation mode, the calculator logs what it would do but does NOT call evcc set_buffer_soc()"
    - "In live mode, the calculator calls evcc set_buffer_soc() only when target changes"
    - "Buffer never drops below 10% hard floor and practical minimum is 20%"
    - "Observation mode auto-transitions to live after 14 days; deployment timestamp survives restarts"
    - "User can manually activate live early or extend observation via API"
    - "Buffer calculation is skipped when bat-to-EV is active (no value fighting)"
    - "Every cycle produces a result dict that StateStore broadcasts via SSE"
  artifacts:
    - path: "evcc-smartload/rootfs/app/dynamic_buffer.py"
      provides: "DynamicBufferCalc engine with formula, event log, observation mode, persistence"
      min_lines: 250
    - path: "evcc-smartload/rootfs/app/main.py"
      provides: "DynamicBufferCalc wired into decision loop after LP/holistic step"
      contains: "buffer_calc"
    - path: "evcc-smartload/rootfs/app/state_store.py"
      provides: "buffer_result field in update(), snapshot, and SSE payload"
      contains: "buffer_result"
  key_links:
    - from: "evcc-smartload/rootfs/app/main.py"
      to: "evcc-smartload/rootfs/app/dynamic_buffer.py"
      via: "buffer_calc.step() call each cycle"
      pattern: "buffer_calc\\.step\\("
    - from: "evcc-smartload/rootfs/app/dynamic_buffer.py"
      to: "evcc-smartload/rootfs/app/evcc_client.py"
      via: "set_buffer_soc() in live mode"
      pattern: "_evcc\\.set_buffer_soc\\("
    - from: "evcc-smartload/rootfs/app/main.py"
      to: "evcc-smartload/rootfs/app/state_store.py"
      via: "buffer_result= parameter in store.update()"
      pattern: "buffer_result=buffer_result"
    - from: "evcc-smartload/rootfs/app/state_store.py"
      to: "SSE clients"
      via: "buffer key in _snapshot_to_json_dict()"
      pattern: '"buffer".*buffer_result'
---

<objective>
Create the DynamicBufferCalc engine, wire it into the main decision loop, and extend StateStore to broadcast buffer state via SSE.

Purpose: Implements the core backend for PLAN-03 (situational battery minimum SoC). The calculator reads existing signals (PV confidence, price spread, time of day) and adjusts the evcc buffer SoC. An observation mode runs for the first 14 days, logging what the system would do without applying changes. All state is persisted across restarts and broadcast to the dashboard via SSE.

Output: `dynamic_buffer.py` module, updated `main.py` with integration, updated `state_store.py` with buffer_result field and SSE payload.
</objective>

<execution_context>
@C:/Users/nicok/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/nicok/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-dynamic-buffer/05-RESEARCH.md
@evcc-smartload/rootfs/app/main.py
@evcc-smartload/rootfs/app/state_store.py
@evcc-smartload/rootfs/app/controller.py
@evcc-smartload/rootfs/app/forecaster/pv.py
@evcc-smartload/rootfs/app/evcc_client.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create DynamicBufferCalc module with formula, observation mode, and persistence</name>
  <files>evcc-smartload/rootfs/app/dynamic_buffer.py</files>
  <action>
Create `dynamic_buffer.py` following the detailed pattern from 05-RESEARCH.md Pattern 1. Key implementation details:

**BufferEvent class:**
- `__slots__` dataclass with: ts, mode, pv_confidence, price_spread_ct, hour_of_day, expected_pv_kw, old_buffer_pct, new_buffer_pct, reason, applied
- `to_dict()` method returning JSON-serializable dict (pv_confidence as 0-100%, price_spread in ct)

**DynamicBufferCalc class:**
- Constructor: receives `cfg` and `evcc_client`, initializes lock, loads persisted state
- Constants: HARD_FLOOR_PCT=10, PRACTICAL_MIN_PCT=20, CONFIDENCE_REDUCTION_THRESHOLD=0.65, OBSERVATION_PERIOD_SECONDS=14*86400, MAX_LOG_ENTRIES=700

**`step()` method** (called every 15-min cycle):
- Parameters: pv_confidence (0.0-1.0), price_spread (EUR/kWh), pv_96 (list), now (optional datetime)
- Calls `_determine_mode(now)` to get "observation" or "live"
- Calls `_compute_target()` for target buffer %
- In live mode: calls `_evcc.set_buffer_soc(target)` ONLY when target differs from current
- Always logs a BufferEvent (applied=True in live, False in observation)
- Calls `_save()` after each cycle
- Returns dict: {current_buffer_pct, mode, days_remaining, log_recent (last 100 entries as dicts), observation_live_at}

**`_compute_target()` method** (conservative formula per user decision):
- Base = cfg.battery_min_soc (e.g. 20-30%)
- max_reduction = base - PRACTICAL_MIN_PCT (e.g. if base=30, can reduce by 10)
- If confidence <= CONFIDENCE_REDUCTION_THRESHOLD or max_reduction==0: return base
- conf_factor = (confidence - threshold) / (1.0 - threshold) -- linear scale
- spread_bonus = 0.1 if price_spread > 0.10 EUR/kWh else 0.0
- time_bonus = 0.1 if hour in 5..10 else 0.0
- total_factor = min(1.0, conf_factor + spread_bonus + time_bonus)
- reduction = int(max_reduction * total_factor)
- target = max(base - reduction, PRACTICAL_MIN_PCT, HARD_FLOOR_PCT)
- Apply hysteresis: round target to nearest 5% to prevent oscillation (Pitfall 4 from research)

**`_determine_mode()` method:**
- If _live_override is True -> "live"
- If _live_override is False -> check _observation_extended_until, return "observation" if before deadline, else "live"
- Auto mode: set _deployment_ts on first call, check elapsed vs OBSERVATION_PERIOD_SECONDS

**Persistence** (`_load()` / `_save()` / `_save_unlocked()`):
- Path: /data/smartload_buffer_model.json, version=1
- Persists: deployment_ts, live_override, current_buffer_pct, log (as list of dicts)
- Atomic write: write to .tmp then os.rename (same pattern as PVForecaster._save())
- `_load()` must reconstruct log entries as plain dicts (not BufferEvent objects) for simplicity
- CRITICAL: _deployment_ts MUST be persisted and restored to prevent observation mode reset on restart (Pitfall 3)

**Manual override API methods:**
- `activate_live()` -- sets _live_override=True, saves
- `extend_observation(extra_days=14)` -- sets _live_override=False, _observation_extended_until = now + extra_days, saves

**Helper methods:**
- `_sum_next_4h_pv(pv_96)` -- sum first 16 slots for logging
- `_days_remaining(now)` -- compute remaining observation days
- `_live_activation_ts()` -- compute when observation ends
- `_build_reason(confidence, spread, target, mode)` -- German-language reason string: "Konfidenz X% . Spread Yct . Puffer Z% . [Simulation]"

**Thread safety:**
- All state access guarded by `_lock` (threading.Lock)
- `_save()` acquires lock, serializes, releases lock, then writes file (Pitfall 2: no I/O under lock)

**Anti-patterns to avoid:**
- Do NOT call set_buffer_soc() every cycle unconditionally (only on change, only in live mode)
- Do NOT compute confidence internally (receive it as parameter from PVForecaster.confidence)
- Do NOT use notifications for buffer changes (user decision: passive logging only)
  </action>
  <verify>
    <automated>cd C:/Users/nicok/projects/smartload && python -c "
import sys; sys.path.insert(0, 'evcc-smartload/rootfs/app')
from dynamic_buffer import DynamicBufferCalc, BufferEvent, HARD_FLOOR_PCT, PRACTICAL_MIN_PCT, CONFIDENCE_REDUCTION_THRESHOLD
# Verify constants
assert HARD_FLOOR_PCT == 10
assert PRACTICAL_MIN_PCT == 20
assert CONFIDENCE_REDUCTION_THRESHOLD == 0.65
# Verify class exists with expected methods
assert hasattr(DynamicBufferCalc, 'step')
assert hasattr(DynamicBufferCalc, 'activate_live')
assert hasattr(DynamicBufferCalc, 'extend_observation')
assert hasattr(BufferEvent, 'to_dict')
print('dynamic_buffer.py: all checks passed')
"</automated>
    <manual>Review dynamic_buffer.py for formula correctness and persistence logic</manual>
  </verify>
  <done>DynamicBufferCalc module exists with conservative formula (20% practical min, 10% hard floor), observation mode with 14-day auto-transition, JSON persistence with atomic writes, hysteresis to prevent oscillation, and German-language reason strings</done>
</task>

<task type="auto">
  <name>Task 2: Wire DynamicBufferCalc into main loop and extend StateStore SSE payload</name>
  <files>evcc-smartload/rootfs/app/main.py, evcc-smartload/rootfs/app/state_store.py</files>
  <action>
**main.py changes:**

1. After the HorizonPlanner initialization block (around line 128), add DynamicBufferCalc initialization with the same graceful fallback pattern:
```python
# --- Phase 5: DynamicBufferCalc (situational battery min SoC) ---
buffer_calc = None
try:
    from dynamic_buffer import DynamicBufferCalc
    buffer_calc = DynamicBufferCalc(cfg, evcc)
    log("info", "DynamicBufferCalc: initialized")
except Exception as e:
    log("warning", f"DynamicBufferCalc: init failed ({e}), buffer management disabled")
```

2. In the decision loop, AFTER the bat-to-EV block (`_run_bat_to_ev(...)` call, around line 318) and BEFORE `store.update(...)` (around line 350), add the buffer calculation:
```python
# --- Phase 5: Dynamic Buffer ---
buffer_result = None
if buffer_calc is not None and not controller._bat_to_ev_active:
    try:
        buffer_result = buffer_calc.step(
            pv_confidence=pv_forecaster.confidence,
            price_spread=state.price_spread,
            pv_96=pv_96 or [],
            now=datetime.now(timezone.utc),
        )
    except Exception as e:
        log("warning", f"DynamicBufferCalc: step failed ({e})")
```
Note: Checking `controller._bat_to_ev_active` prevents value fighting with the bat-to-EV logic (Pitfall 6 from research). The try/except ensures a buffer failure never crashes the main loop.

3. Add `buffer_result=buffer_result` parameter to the existing `store.update(...)` call (add it as the last keyword argument).

**state_store.py changes:**

1. In `__init__()`: add `self._buffer_result: Optional[dict] = None` after the existing forecast fields (around line 57).

2. In `update()` signature: add `buffer_result: Optional[dict] = None` as the last parameter.

3. In `update()` body (inside `with self._lock:`): add `self._buffer_result = buffer_result` alongside the other field assignments.

4. In `_snapshot_unlocked()`: add `"buffer_result": copy.copy(self._buffer_result)` to the snap dict (after the ha_warnings line, before the plan section).

5. In `_snapshot_to_json_dict()`: add `"buffer": snap.get("buffer_result"),` to the returned dict (after the "plan_summary" key). This makes the buffer result available as `data.buffer` in the SSE payload for the dashboard JS.
  </action>
  <verify>
    <automated>cd C:/Users/nicok/projects/smartload && python -c "
import sys; sys.path.insert(0, 'evcc-smartload/rootfs/app')
# Verify StateStore has buffer_result in update signature
import inspect
from state_store import StateStore
sig = inspect.signature(StateStore.update)
assert 'buffer_result' in sig.parameters, 'buffer_result not in update() signature'
# Verify _snapshot_to_json_dict includes buffer key
import state_store
src = inspect.getsource(state_store._snapshot_to_json_dict)
assert 'buffer' in src, 'buffer key not in _snapshot_to_json_dict'
print('state_store.py: buffer integration checks passed')
" && grep -q 'buffer_calc' evcc-smartload/rootfs/app/main.py && echo "main.py: buffer_calc found" && grep -q 'buffer_result=buffer_result' evcc-smartload/rootfs/app/main.py && echo "main.py: buffer_result wired to store.update()"</automated>
  </verify>
  <done>DynamicBufferCalc is initialized at startup with graceful fallback, called every 15-min cycle (skipped during bat-to-EV), buffer_result flows through StateStore.update() into SSE payload as data.buffer, and any buffer failure is caught without crashing the main loop</done>
</task>

</tasks>

<verification>
1. `dynamic_buffer.py` exists with DynamicBufferCalc class, BufferEvent, and all constants
2. `main.py` initializes buffer_calc after horizon_planner, calls step() in loop, passes buffer_result to store.update()
3. `state_store.py` update() accepts buffer_result, includes it in snapshot and SSE JSON as "buffer" key
4. buffer_calc.step() is wrapped in try/except in main loop â€” never crashes the decision loop
5. buffer_calc skipped when controller._bat_to_ev_active is True
6. Formula enforces 10% hard floor and 20% practical minimum
7. Observation mode persists deployment_ts across restarts
</verification>

<success_criteria>
- DynamicBufferCalc computes target buffer every cycle using PV confidence, price spread, and time of day
- Observation mode logs but does not apply; auto-transitions to live after 14 days
- Live mode calls evcc set_buffer_soc() only on change
- Buffer result is available in SSE payload for dashboard consumption
- No new dependencies required (stdlib only)
</success_criteria>

<output>
After completion, create `.planning/phases/05-dynamic-buffer/05-01-SUMMARY.md`
</output>

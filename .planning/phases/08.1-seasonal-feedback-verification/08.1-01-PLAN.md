---
phase: "08.1-seasonal-feedback-verification"
plan: "01"
type: execute
wave: 1
depends_on: []
files_modified:
  - evcc-smartload/rootfs/app/main.py
  - evcc-smartload/rootfs/app/optimizer/planner.py
  - .planning/phases/05-dynamic-buffer/05-VERIFICATION.md
autonomous: true
requirements: [LERN-02, PLAN-03]
must_haves:
  truths:
    - "SeasonalLearner.get_correction_factor() is called every decision cycle in main.py and its output flows into HorizonPlanner.plan()"
    - "The LP solver applies a dampened, capped seasonal cost offset to normal-cost charging slots (not penalty slots)"
    - "When seasonal data is sparse (get_correction_factor returns None), the correction is 0.0 and the LP behaves identically to before"
    - "The seasonal correction is passed to both the primary plan() call and the ReactionTimingTracker re-plan call"
    - "Phase 5 Dynamic Buffer has a VERIFICATION.md confirming all must_haves from both 05-01-PLAN.md and 05-02-PLAN.md"
  artifacts:
    - path: "evcc-smartload/rootfs/app/main.py"
      provides: "_seasonal_correction_eur() helper function and wiring into both plan() calls"
      contains: "_seasonal_correction_eur"
    - path: "evcc-smartload/rootfs/app/optimizer/planner.py"
      provides: "seasonal_correction_eur parameter on plan() and _solve_lp(), applied to c[t] in else branches"
      contains: "seasonal_correction_eur"
    - path: ".planning/phases/05-dynamic-buffer/05-VERIFICATION.md"
      provides: "Formal verification of all Phase 5 must_haves with code evidence"
      min_lines: 80
  key_links:
    - from: "evcc-smartload/rootfs/app/main.py"
      to: "evcc-smartload/rootfs/app/seasonal_learner.py"
      via: "_seasonal_correction_eur() calls seasonal_learner.get_correction_factor()"
      pattern: "get_correction_factor"
    - from: "evcc-smartload/rootfs/app/main.py"
      to: "evcc-smartload/rootfs/app/optimizer/planner.py"
      via: "seasonal_correction_eur= parameter in plan() calls"
      pattern: "seasonal_correction_eur=_seasonal_corr"
    - from: "evcc-smartload/rootfs/app/optimizer/planner.py"
      to: "LP cost vector c[t]"
      via: "seasonal_correction_eur added to effective_price in normal-cost else branches"
      pattern: "effective_price + seasonal_correction_eur"
---

<objective>
Wire SeasonalLearner.get_correction_factor() into the HorizonPlanner LP objective as a dampened, capped seasonal cost offset, and create formal VERIFICATION.md for Phase 5 Dynamic Buffer.

Purpose: Closes two v1.0 audit gaps. LERN-02: SeasonalLearner has been accumulating plan errors since Phase 8 but its corrections never flow back to the LP optimizer. PLAN-03: Phase 5 Dynamic Buffer is implemented and working but lacks formal verification documentation.

Output: Updated `main.py` with seasonal correction helper and wiring, updated `planner.py` with `seasonal_correction_eur` parameter threaded into LP cost vector, and `05-VERIFICATION.md` documenting Phase 5 must_have compliance.
</objective>

<execution_context>
@C:/Users/nicok/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/nicok/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08.1-seasonal-feedback-verification/08.1-RESEARCH.md
@.planning/phases/08-residual-rl-and-learning/08-03-SUMMARY.md
@.planning/phases/05-dynamic-buffer/05-01-PLAN.md
@.planning/phases/05-dynamic-buffer/05-02-PLAN.md
@evcc-smartload/rootfs/app/main.py
@evcc-smartload/rootfs/app/optimizer/planner.py
@evcc-smartload/rootfs/app/seasonal_learner.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire seasonal correction into main.py and planner.py LP objective</name>
  <files>evcc-smartload/rootfs/app/main.py, evcc-smartload/rootfs/app/optimizer/planner.py</files>
  <action>
**main.py changes:**

1. Add a module-level helper function `_seasonal_correction_eur()` near the other Phase 8 helpers (`_current_slot_index()`, `_compute_slot0_cost()`, etc.). Per user decision: conservative dampening, always-execute code path, safety cap.

```python
_SEASONAL_DAMPING = 0.5        # Apply only 50% of historical error (conservative per user decision)
_SEASONAL_CAP_EUR_KWH = 0.05  # Max correction +/-5ct/kWh (safety cap)

def _seasonal_correction_eur(seasonal_learner, now: datetime) -> float:
    """Return a dampened, capped seasonal cost correction (EUR/kWh).

    Returns 0.0 when seasonal_learner is None or data is insufficient.
    Positive = plan historically underestimated costs -> raise cost -> charge less.
    Negative = plan historically overestimated costs -> lower cost -> charge more.

    Note: mean_error_eur from SeasonalLearner is an approximate EUR-per-slot value.
    The safety cap ensures the correction stays in a safe range regardless of exact
    unit interpretation. This is consistent with the 'dampen toward neutral' approach.
    """
    if seasonal_learner is None:
        return 0.0
    try:
        raw = seasonal_learner.get_correction_factor(now)
    except Exception:
        return 0.0
    if raw is None:
        return 0.0  # sparse data -- stay neutral
    dampened = raw * _SEASONAL_DAMPING
    return max(-_SEASONAL_CAP_EUR_KWH, min(_SEASONAL_CAP_EUR_KWH, dampened))
```

2. In the main decision loop, BEFORE the primary `horizon_planner.plan()` call (currently around lines 406-414), compute the seasonal correction and store it in a loop variable:

```python
# --- Phase 8.1: Seasonal cost correction ---
_seasonal_corr = _seasonal_correction_eur(seasonal_learner, datetime.now(timezone.utc))
```

3. Add `seasonal_correction_eur=_seasonal_corr` as a keyword argument to the primary `horizon_planner.plan()` call (lines 406-414).

4. CRITICAL (Pitfall 5 from research): Also add `seasonal_correction_eur=_seasonal_corr` to the second `horizon_planner.plan()` call in the ReactionTimingTracker re-plan path (around lines 621-633). Both plan() calls must receive the same seasonal correction.

5. Add a DEBUG-level log line when the correction is non-zero, near the plan() call:
```python
if _seasonal_corr != 0.0:
    log("info", f"Seasonal correction: {_seasonal_corr:+.4f} EUR/kWh applied to LP objective")
```

**planner.py changes:**

1. Add `seasonal_correction_eur: float = 0.0` parameter to `plan()` method signature, after the existing `confidence_factors` parameter.

2. Thread `seasonal_correction_eur` from `plan()` down to `_solve_lp()`: add it as a parameter to the `_solve_lp()` call inside `plan()`, and add the corresponding parameter to the `_solve_lp()` method signature.

3. Inside `_solve_lp()`, in the per-slot cost coefficient loop (currently around lines 282-314), apply the seasonal correction to the `else` branches ONLY (not the over-price penalty branches):

For battery charging slots:
```python
if price_96[t] > self._bat_max_price:
    c[i_bat_chg + t] = price_96[t] * 10.0   # penalty -- no seasonal offset
else:
    c[i_bat_chg + t] = effective_price + seasonal_correction_eur  # Phase 8.1
```

For EV charging slots:
```python
if price_96[t] > self._ev_max_price and ev_connected:
    c[i_ev_chg + t] = price_96[t] * 10.0    # penalty -- no seasonal offset
else:
    c[i_ev_chg + t] = effective_price + seasonal_correction_eur  # Phase 8.1
```

Do NOT apply the correction to discharge slots (`c[i_bat_dis + t] = -self._feed_in` remains unchanged).

**Anti-patterns to avoid:**
- Do NOT apply seasonal offset to penalty slots (price * 10.0) -- these gate out over-price charging and must stay unchanged.
- Do NOT mutate the existing `confidence_factors` dict -- seasonal correction is a separate parameter.
- Do NOT skip the helper call when seasonal_learner is None -- the helper handles None safely (returns 0.0).
- Do NOT mix EUR and ct units -- the LP cost vector uses EUR/kWh throughout.
  </action>
  <verify>
    <automated>cd C:/Users/nicok/projects/smartload && python -c "
import sys; sys.path.insert(0, 'evcc-smartload/rootfs/app')
# Verify helper exists and works
from main import _seasonal_correction_eur, _SEASONAL_DAMPING, _SEASONAL_CAP_EUR_KWH
assert _SEASONAL_DAMPING == 0.5, f'Expected 0.5, got {_SEASONAL_DAMPING}'
assert _SEASONAL_CAP_EUR_KWH == 0.05, f'Expected 0.05, got {_SEASONAL_CAP_EUR_KWH}'
# Test None learner
assert _seasonal_correction_eur(None, None) == 0.0
# Test with mock
class MockLearner:
    def get_correction_factor(self, dt): return 0.08
mock = MockLearner()
from datetime import datetime, timezone
result = _seasonal_correction_eur(mock, datetime.now(timezone.utc))
assert result == 0.04, f'Expected 0.04 (0.08*0.5), got {result}'
# Test cap
class BigLearner:
    def get_correction_factor(self, dt): return 0.5
big = BigLearner()
result = _seasonal_correction_eur(big, datetime.now(timezone.utc))
assert result == 0.05, f'Expected cap 0.05, got {result}'
# Test None return from learner
class SparseLearner:
    def get_correction_factor(self, dt): return None
sparse = SparseLearner()
assert _seasonal_correction_eur(sparse, datetime.now(timezone.utc)) == 0.0
print('main.py: _seasonal_correction_eur helper OK')
" && grep -c "seasonal_correction_eur" evcc-smartload/rootfs/app/optimizer/planner.py && echo "planner.py: seasonal_correction_eur references found" && grep -c "seasonal_correction_eur=_seasonal_corr" evcc-smartload/rootfs/app/main.py && echo "main.py: seasonal_corr passed to plan() calls"</automated>
  </verify>
  <done>SeasonalLearner.get_correction_factor() is called every cycle via _seasonal_correction_eur() helper with 50% dampening and +/-0.05 EUR/kWh cap. The correction flows to both plan() calls (primary and re-plan). HorizonPlanner._solve_lp() applies it to normal-cost charging slots only (not penalty slots). Sparse data returns 0.0 (neutral). Non-zero corrections are logged at INFO level.</done>
</task>

<task type="auto">
  <name>Task 2: Create Phase 5 Dynamic Buffer VERIFICATION.md</name>
  <files>.planning/phases/05-dynamic-buffer/05-VERIFICATION.md</files>
  <action>
Create a formal VERIFICATION.md for Phase 5 Dynamic Buffer by walking through EVERY must_have from both 05-01-PLAN.md and 05-02-PLAN.md against the actual codebase.

**Process:**
1. Read each source file referenced in the Phase 5 must_haves:
   - `evcc-smartload/rootfs/app/dynamic_buffer.py`
   - `evcc-smartload/rootfs/app/main.py`
   - `evcc-smartload/rootfs/app/state_store.py`
   - `evcc-smartload/rootfs/app/web/templates/dashboard.html`
   - `evcc-smartload/rootfs/app/web/static/app.js`
   - `evcc-smartload/rootfs/app/web/server.py`

2. For each must_have truth (8 from Plan 01, 7 from Plan 02), check if the code implements it. Cite specific file, function/method, and grep-confirming pattern.

3. For each must_have artifact (3 from Plan 01, 3 from Plan 02), confirm the file exists and meets the minimum criteria (line count, required exports/contains).

4. For each key_link (4 from Plan 01, 3 from Plan 02), confirm the wiring exists with a grep pattern match.

5. Per user decision: if ANY must_have is NOT fully implemented, FIX IT in this task before marking PASS. Do not just document the gap.

**VERIFICATION.md format:**

```markdown
# Phase 5 Dynamic Buffer -- Verification

**Verified:** 2026-02-23
**Audited by:** Phase 8.1 gap closure
**Result:** PASS / PARTIAL (with details)

## Plan 01: Backend Engine

### Must-Have Truths

#### Truth 1: "DynamicBufferCalc computes a target buffer SoC every 15-minute cycle..."
**Status:** PASS
**Evidence:** `dynamic_buffer.py` `step()` method calls `_compute_target()` each cycle.
  File: `evcc-smartload/rootfs/app/dynamic_buffer.py`
  Pattern: `target = self._compute_target(`

[Continue for all 8 truths]

### Must-Have Artifacts

#### Artifact: evcc-smartload/rootfs/app/dynamic_buffer.py
**Status:** PASS
**Evidence:** File exists, {N} lines (>= min 250). Contains DynamicBufferCalc with all required methods.

[Continue for all 3 artifacts]

### Key Links

#### Link: main.py -> dynamic_buffer.py via buffer_calc.step()
**Status:** PASS
**Evidence:** `main.py` contains `buffer_calc.step(`

[Continue for all 4 links]

## Plan 02: Dashboard UI

[Same structure for 7 truths, 3 artifacts, 3 key links]

## Summary

All {N} must_haves verified. Result: PASS.
```

**Key verification commands** (use grep to confirm each):
- Plan 01 truths: `_compute_target(`, `set_buffer_soc(`, `HARD_FLOOR_PCT`, `PRACTICAL_MIN_PCT`, `_deployment_ts`, `activate_live`, `_bat_to_ev_active`, `buffer_result`
- Plan 02 truths: `bufferCard`, `bufferObsBanner`, `renderBufferChart`, `renderBufferLog`, `buffer-log-obs`, `/buffer/activate-live`, `updateBufferSection`
- Artifacts: file existence + line counts + required contains strings
- Key links: specific wiring patterns from the plan frontmatter

If any grep fails (code doesn't exist), implement the missing piece and then document both the fix and the verification.
  </action>
  <verify>
    <automated>cd C:/Users/nicok/projects/smartload && test -f .planning/phases/05-dynamic-buffer/05-VERIFICATION.md && echo "VERIFICATION.md exists" && grep -c "PASS" .planning/phases/05-dynamic-buffer/05-VERIFICATION.md && echo "PASS entries found" && grep -q "Result:" .planning/phases/05-dynamic-buffer/05-VERIFICATION.md && echo "Result line present"</automated>
  </verify>
  <done>05-VERIFICATION.md exists documenting every Phase 5 must_have (15 truths, 6 artifacts, 7 key links) with PASS/FAIL status and specific code evidence. Any gaps found during verification have been fixed before marking PASS.</done>
</task>

</tasks>

<verification>
1. `main.py` contains `_seasonal_correction_eur()` helper with dampening 0.5 and cap 0.05
2. `main.py` calls `_seasonal_correction_eur(seasonal_learner, ...)` before plan() calls
3. `main.py` passes `seasonal_correction_eur=_seasonal_corr` to BOTH plan() calls (primary + re-plan)
4. `planner.py` `plan()` accepts `seasonal_correction_eur` parameter and threads to `_solve_lp()`
5. `planner.py` `_solve_lp()` adds `seasonal_correction_eur` to `effective_price` in normal-cost else branches only
6. Penalty slots (`price_96[t] * 10.0`) do NOT receive seasonal offset
7. Discharge slots unchanged (`-self._feed_in`)
8. `05-VERIFICATION.md` exists with all Phase 5 must_haves audited
9. No Phase 5 must_have is documented as FAIL without a corresponding fix
</verification>

<success_criteria>
- SeasonalLearner corrections flow into LP cost coefficients: LERN-02 closed
- Correction is conservative: 50% dampened, capped at +/-0.05 EUR/kWh, 0.0 when sparse
- Both plan() calls (primary and re-plan) receive the seasonal correction
- Phase 5 VERIFICATION.md confirms all must_haves with code evidence: PLAN-03 closed
- No new dependencies added
</success_criteria>

<output>
After completion, create `.planning/phases/08.1-seasonal-feedback-verification/08.1-01-SUMMARY.md`
</output>

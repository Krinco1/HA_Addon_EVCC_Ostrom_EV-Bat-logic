---
phase: 07-driver-interaction
plan: 02
type: execute
wave: 2
depends_on: ["07-01"]
files_modified:
  - evcc-smartload/rootfs/app/departure_store.py
  - evcc-smartload/rootfs/app/main.py
  - evcc-smartload/rootfs/app/notification.py
  - evcc-smartload/rootfs/app/web/server.py
autonomous: true
requirements: [DRIV-02]

must_haves:
  truths:
    - "When a vehicle is plugged in, the system sends a Telegram message asking the driver for departure time within one decision cycle"
    - "Driver can reply via inline time buttons (In 2h, In 4h, In 8h, Morgen frueh) or free text (um 14:30, in 3 Stunden)"
    - "If driver does not reply within 30 minutes, system silently falls back to configured default departure time"
    - "Confirmed departure time is fed into HorizonPlanner via _get_departure_times() each cycle"
    - "Departure times persist across add-on restarts"
  artifacts:
    - path: "evcc-smartload/rootfs/app/departure_store.py"
      provides: "DepartureTimeStore with set/get/clear, JSON persistence, parse_departure_time()"
      contains: "class DepartureTimeStore"
    - path: "evcc-smartload/rootfs/app/notification.py"
      provides: "send_departure_inquiry() and departure callback/text handlers"
      contains: "send_departure_inquiry"
    - path: "evcc-smartload/rootfs/app/main.py"
      provides: "Plug-in event detection and _get_departure_times() using DepartureTimeStore"
      contains: "departure_store"
  key_links:
    - from: "evcc-smartload/rootfs/app/main.py"
      to: "departure_store.get()"
      via: "_get_departure_times() reads per-vehicle departure from store"
      pattern: "departure_store\\.get"
    - from: "evcc-smartload/rootfs/app/notification.py"
      to: "departure_store.set()"
      via: "Telegram callback handler writes confirmed departure"
      pattern: "departure_store\\.set"
    - from: "evcc-smartload/rootfs/app/main.py"
      to: "notifier.send_departure_inquiry()"
      via: "Plug-in detection triggers Telegram inquiry"
      pattern: "send_departure_inquiry"
---

<objective>
Implement proactive departure-time queries via Telegram: detect vehicle plug-in events, send a German-language inquiry with inline time buttons, parse driver replies (button or free text), and feed confirmed departure times into the HorizonPlanner.

Purpose: The LP planner produces better plans when it knows actual departure times rather than using a static default. Asking the driver proactively reduces friction vs requiring them to remember to set it.
Output: DepartureTimeStore with persistence, Telegram departure inquiry flow, plug-in detection in main loop.
</objective>

<execution_context>
@C:/Users/nicok/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/nicok/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-driver-interaction/07-RESEARCH.md
@.planning/phases/07-driver-interaction/07-01-SUMMARY.md
@.planning/phases/04-predictive-planner/04-02-SUMMARY.md

# Key source files
@evcc-smartload/rootfs/app/main.py
@evcc-smartload/rootfs/app/notification.py
@evcc-smartload/rootfs/app/state.py
@evcc-smartload/rootfs/app/driver_manager.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create DepartureTimeStore with persistence and departure time parser</name>
  <files>
    evcc-smartload/rootfs/app/departure_store.py
  </files>
  <action>
Create `departure_store.py` with two components:

**1. parse_departure_time(text: str, now: datetime) -> Optional[datetime]**

A standalone function that parses German-language departure time expressions. Must handle these cases (per locked decisions in CONTEXT.md):

- `"in 2h"` / `"in 2 Stunden"` / `"in 3 std"` → now + N hours
- `"um 14:30"` / `"um 14 Uhr"` → today at HH:MM (or tomorrow if time has passed)
- `"morgen frueh"` / `"morgen"` → tomorrow at 07:00
- Inline button shorthand: `"2h"`, `"4h"`, `"8h"`, `"morgen"` → same as above
- Return `None` for unparseable input

Use `re` module (stdlib, already used in the codebase). Text should be `.strip().lower()` before matching. Handle German comma decimals in hours (e.g., `"in 2,5 Stunden"` → 2.5 hours).

**2. DepartureTimeStore class**

Thread-safe store mapping vehicle_name -> departure datetime, with JSON file persistence (same pattern as ManualSocStore in state.py: `/data/smartprice_departure_times.json`).

Constructor `__init__(self, default_hour: int = 6, persist_path: str = "/data/smartprice_departure_times.json")`:
- `self._lock = threading.Lock()`
- `self._times: Dict[str, str] = {}` (store ISO strings for JSON serialization)
- `self._default_hour = default_hour`
- `self._persist_path = persist_path`
- `self._pending_inquiries: Dict[str, datetime] = {}` (track when inquiry was sent, for 30-min timeout)
- Call `self._load()` to restore from disk on init.

Methods:
- `set(vehicle_name: str, departure: datetime)`: Under lock, store `departure.isoformat()`. Call `_save()`. Remove from `_pending_inquiries`.
- `get(vehicle_name: str) -> datetime`: Under lock, if vehicle has a stored departure AND it's in the future, return it. Otherwise compute fallback: next occurrence of `self._default_hour` (today or tomorrow).
- `clear(vehicle_name: str)`: Under lock, remove vehicle entry, `_save()`.
- `mark_inquiry_sent(vehicle_name: str)`: Under lock, record `datetime.now(timezone.utc)` in `_pending_inquiries`.
- `is_inquiry_pending(vehicle_name: str) -> bool`: Under lock, check if inquiry was sent within last 30 minutes. If sent > 30 min ago, remove it (timeout) and return False.
- `_load()`: Read JSON file if exists, populate `_times` dict. Handle missing/corrupt file gracefully (log warning, start empty).
- `_save()`: Write `_times` dict to JSON file. Wrap in try/except (non-critical).

Use `from logging_util import log` for logging. Use `from datetime import datetime, timedelta, timezone` and `import threading, json, os, re` for dependencies. Use `from typing import Dict, Optional` for type hints.
  </action>
  <verify>
    <automated>cd evcc-smartload && python -c "
import sys, os; sys.path.insert(0, 'rootfs/app')
os.makedirs('/tmp/test_dep', exist_ok=True)
# Mock logging_util
import types; lm = types.ModuleType('logging_util'); lm.log = lambda *a: None; sys.modules['logging_util'] = lm
from departure_store import DepartureTimeStore, parse_departure_time
from datetime import datetime, timedelta, timezone
now = datetime.now(timezone.utc)
# Test parser
assert parse_departure_time('in 2h', now) is not None, 'Failed: in 2h'
assert parse_departure_time('um 14:30', now) is not None, 'Failed: um 14:30'
assert parse_departure_time('morgen', now) is not None, 'Failed: morgen'
assert parse_departure_time('4h', now) is not None, 'Failed: 4h'
assert parse_departure_time('xyz garbage', now) is None, 'Failed: garbage should be None'
# Test store
ds = DepartureTimeStore(default_hour=7, persist_path='/tmp/test_dep/test.json')
ds.set('KIA', now + timedelta(hours=5))
result = ds.get('KIA')
assert result > now, 'Stored departure should be in the future'
ds.clear('KIA')
print('ALL CHECKS PASSED')
"</automated>
  </verify>
  <done>DepartureTimeStore class exists with set/get/clear/persistence. parse_departure_time() handles all 4 German time expression patterns. Pending inquiry tracking with 30-min timeout works.</done>
</task>

<task type="auto">
  <name>Task 2: Plug-in detection, Telegram departure inquiry, and _get_departure_times() integration</name>
  <files>
    evcc-smartload/rootfs/app/main.py
    evcc-smartload/rootfs/app/notification.py
    evcc-smartload/rootfs/app/web/server.py
  </files>
  <action>
**main.py — Plug-in event detection and DepartureTimeStore wiring:**

1. Import DepartureTimeStore: `from departure_store import DepartureTimeStore`
2. Initialize before main loop: `departure_store = DepartureTimeStore(default_hour=cfg.ev_charge_deadline_hour)` with try/except fallback to None.
3. Inject into notifier: `notifier.departure_store = departure_store` (late attribute, same pattern as override_manager).
4. Inject into web server: `srv.departure_store = departure_store`.

5. Add plug-in detection state variable before main loop: `last_ev_connected = False` and `last_ev_name = ""`.
6. In each decision cycle, AFTER collecting state (after `state = collector.get_current_state()`), detect plug-in:
   ```python
   ev_just_plugged_in = state.ev_connected and not last_ev_connected
   if ev_just_plugged_in and state.ev_name and notifier and departure_store:
       if not departure_store.is_inquiry_pending(state.ev_name):
           notifier.send_departure_inquiry(state.ev_name, state.ev_soc)
           departure_store.mark_inquiry_sent(state.ev_name)
   # Handle deferred check: name was empty on plug-in
   if state.ev_connected and not last_ev_connected and not state.ev_name:
       pass  # next cycle will re-check since last_ev_connected updates below
   # Only update last_ev_connected when ev_name is known (avoid false-negative on next cycle)
   if state.ev_name or not state.ev_connected:
       last_ev_connected = state.ev_connected
       last_ev_name = state.ev_name or ""
   ```

7. Replace `_get_departure_times(cfg)` with `_get_departure_times(departure_store, cfg)`:
   - If departure_store is not None: return `{vehicle_name: departure_store.get(vehicle_name) for vehicle_name in ...}` for all known vehicles. Get vehicle names from `state.ev_name` or from the vehicles dict if available.
   - If departure_store is None: fall back to existing behavior (cfg.ev_charge_deadline_hour).
   - Update the call site in the main loop where _get_departure_times is called to pass departure_store.

**notification.py — Departure inquiry and reply handling:**

1. Add `self.departure_store = None` attribute in NotificationManager.__init__ (will be set by main.py).
2. Register callback for departure replies in __init__: `bot.register_callback("depart_", self._handle_departure_callback)`.

3. Implement `send_departure_inquiry(self, vehicle_name: str, current_soc: float)`:
   - Build inline keyboard with 4 time buttons per locked decisions:
     ```python
     safe_name = vehicle_name.replace(" ", "_")
     keyboard = [[
         {"text": "In 2h", "callback_data": f"depart_{safe_name}_2h"},
         {"text": "In 4h", "callback_data": f"depart_{safe_name}_4h"},
         {"text": "In 8h", "callback_data": f"depart_{safe_name}_8h"},
         {"text": "Morgen frueh", "callback_data": f"depart_{safe_name}_morgen"},
     ]]
     ```
   - Compose message in casual German "du" tone: `f"Hey, der {vehicle_name} ist angeschlossen! (SoC: {current_soc:.0f}%) Wann brauchst du ihn?"`
   - Send to all driver chat_ids associated with this vehicle (use driver_manager to look up). If no specific driver, send to all configured chat_ids.
   - Track pending inquiry: `self._pending_departure_vehicle = vehicle_name` (for free-text reply matching).

4. Implement `_handle_departure_callback(self, chat_id: int, data: str)`:
   - Parse callback data: `"depart_KIA_EV9_4h"` → vehicle_name = "KIA EV9", time_str = "4h".
   - Call `parse_departure_time(time_str, datetime.now(timezone.utc))` to get departure datetime.
   - If parsed successfully: call `self.departure_store.set(vehicle_name, departure)`. Reply: `f"Alles klar! {vehicle_name} wird bis {departure.strftime('%H:%M')} fertig sein."` (use local time for display).
   - If parse fails: reply `"Konnte die Zeit nicht verstehen. Versuch es mit z.B. 'in 3h' oder 'um 14:30'."`.

5. Extend `_handle_text_message()` (existing method): At the TOP of the handler (before other text processing), check if there's a pending departure inquiry (`self._pending_departure_vehicle` is set and `self.departure_store.is_inquiry_pending(self._pending_departure_vehicle)`). If so:
   - Import and call `parse_departure_time(text, now)`.
   - If parsed: store via departure_store.set(), reply with confirmation, clear pending state.
   - If NOT parsed: reply with hint: `"Hmm, das hab ich nicht verstanden. Versuch 'in 3h', 'um 14:30' oder tippe auf einen Button oben."`. Do NOT clear pending state (let them retry).

**web/server.py — Optional departure time API:**

Add GET `/departure-times` endpoint: Returns `{vehicle_name: departure_iso}` dict from departure_store for dashboard polling. Guard with None check on self.departure_store.

Import `from departure_store import DepartureTimeStore` is NOT needed — access via `self.departure_store` injected attribute.
  </action>
  <verify>
    <automated>cd evcc-smartload && grep -c "departure_store\|send_departure_inquiry\|ev_just_plugged_in\|depart_" rootfs/app/main.py rootfs/app/notification.py && echo "PATTERNS FOUND"</automated>
    <manual>Verify plug-in detection logic handles deferred ev_name. Verify _get_departure_times uses DepartureTimeStore. Verify Telegram inquiry has correct German text and 4 inline buttons.</manual>
  </verify>
  <done>Plug-in event triggers Telegram departure inquiry with inline time buttons. Driver replies (button or free text) are parsed and stored. _get_departure_times() reads from DepartureTimeStore with config default fallback. Departure times persist to JSON across restarts. 30-minute silent timeout on no reply.</done>
</task>

</tasks>

<verification>
1. `departure_store.py` exists with DepartureTimeStore class and parse_departure_time() function
2. `main.py` detects plug-in events (ev_connected transition) and triggers departure inquiry
3. `notification.py` sends German Telegram inquiry with 4 inline buttons + free text support
4. Departure callback stores confirmed time in DepartureTimeStore
5. `_get_departure_times()` uses DepartureTimeStore.get() per vehicle with config default fallback
6. JSON persistence at `/data/smartprice_departure_times.json` loads on restart
7. 30-minute inquiry timeout works (silent fallback, no spam)
</verification>

<success_criteria>
- When vehicle plugs in, Telegram message sent within one cycle: "Hey, der [vehicle] ist angeschlossen! Wann brauchst du ihn?"
- Inline buttons "In 2h" | "In 4h" | "In 8h" | "Morgen frueh" work
- Free text "um 14:30", "in 3 Stunden" parsed correctly
- 30-minute timeout: no follow-up notification, falls back to config default
- Departure time fed into HorizonPlanner each cycle via _get_departure_times()
- Departure times survive add-on restart (JSON persistence)
</success_criteria>

<output>
After completion, create `.planning/phases/07-driver-interaction/07-02-SUMMARY.md`
</output>

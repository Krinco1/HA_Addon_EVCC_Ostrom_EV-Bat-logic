---
phase: 07-driver-interaction
plan: 03
type: execute
wave: 3
depends_on: ["07-02"]
files_modified:
  - evcc-smartload/rootfs/app/charge_sequencer.py
  - evcc-smartload/rootfs/app/main.py
  - evcc-smartload/rootfs/app/web/static/app.js
autonomous: true
requirements: [DRIV-03]

must_haves:
  truths:
    - "When two vehicles are waiting, the one departing sooner with higher SoC deficit is prioritized over one with lower SoC but later departure"
    - "Urgency score is visible on dashboard vehicle cards with both numeric score and natural language reason"
    - "Priority order is shown on the dashboard"
    - "Connected vehicle gets a tie-break bonus to avoid unnecessary wallbox swaps"
    - "Quiet hours rule is preserved (connected vehicle gets absolute priority during quiet hours)"
  artifacts:
    - path: "evcc-smartload/rootfs/app/charge_sequencer.py"
      provides: "Urgency-based _rank_vehicles() with SoC-deficit/hours-to-departure formula"
      contains: "_urgency_score"
    - path: "evcc-smartload/rootfs/app/web/static/app.js"
      provides: "Dashboard vehicle cards showing urgency score and departure time"
      contains: "urgency_score"
  key_links:
    - from: "evcc-smartload/rootfs/app/charge_sequencer.py"
      to: "departure_store.get()"
      via: "DepartureTimeStore injected into ChargeSequencer for urgency calculation"
      pattern: "departure_store"
    - from: "evcc-smartload/rootfs/app/web/static/app.js"
      to: "/sequencer"
      via: "Vehicle cards read urgency_score from sequencer API response"
      pattern: "urgency_score"
---

<objective>
Replace SoC-only vehicle ranking in ChargeSequencer with urgency scoring (SoC deficit / hours to departure) and show urgency information on dashboard vehicle cards.

Purpose: When two vehicles are waiting, prioritizing by urgency (need vs time available) produces better outcomes than raw SoC ranking. A vehicle departing in 2h at 50% SoC genuinely needs charging more than one departing in 12h at 40% SoC.
Output: Urgency-based multi-EV ranking with transparent scoring on dashboard.
</objective>

<execution_context>
@C:/Users/nicok/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/nicok/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-driver-interaction/07-RESEARCH.md
@.planning/phases/07-driver-interaction/07-01-SUMMARY.md
@.planning/phases/07-driver-interaction/07-02-SUMMARY.md

# Key source files
@evcc-smartload/rootfs/app/charge_sequencer.py
@evcc-smartload/rootfs/app/main.py
@evcc-smartload/rootfs/app/web/static/app.js
@evcc-smartload/rootfs/app/departure_store.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Refactor ChargeSequencer to urgency-based ranking</name>
  <files>
    evcc-smartload/rootfs/app/charge_sequencer.py
    evcc-smartload/rootfs/app/main.py
  </files>
  <action>
**charge_sequencer.py — Urgency scoring refactor:**

1. Add `self.departure_store = None` attribute in ChargeSequencer `__init__`. This will be injected by main.py (same late-assignment pattern).

2. Add `_urgency_score(self, req: ChargeRequest, now: datetime) -> float` method:
   - Get departure time: if `self.departure_store` is not None, call `self.departure_store.get(req.vehicle_name)`. Otherwise use a default 12-hour window.
   - Calculate `hours_remaining = max(0.5, (departure - now).total_seconds() / 3600)`. The 0.5 floor prevents division by near-zero.
   - If departure is in the past (already passed): treat as "no deadline known" — use 12.0 hours (avoid artificially inflating urgency for past departures per research Pitfall 3).
   - Calculate `soc_deficit = max(0, req.target_soc - req.current_soc)` (percentage points, e.g., target 80% - current 50% = 30).
   - Return `soc_deficit / hours_remaining`. Higher score = more urgent.

3. Refactor `_rank_vehicles(self, pending, connected_vehicle, solar_hours, now)`:
   - Replace the existing point-based scoring system with urgency scoring.
   - For each request in pending:
     - `req.priority = self._urgency_score(req, now)`
     - Connected vehicle tie-break: if `req.vehicle_name == connected_vehicle`, add `+5.0` to priority (avoid unnecessary wallbox swap).
     - Quiet hours absolute priority: if `self._is_quiet(now) and req.vehicle_name == connected_vehicle`, add `+1000.0` to priority (preserve existing quiet hours rule).
   - Return `sorted(pending, key=lambda r: r.priority, reverse=True)` (highest urgency first).
   - Log ranking result: `log("info", f"ChargeSequencer: urgency ranking: {[(r.vehicle_name, round(r.priority, 2)) for r in sorted_pending]}")`.

4. Extend `get_requests_summary(self) -> Dict` to include urgency information per vehicle:
   - Add `"urgency_score": round(self._urgency_score(r, now), 2)` to each vehicle entry.
   - Add `"departure_time": self.departure_store.get(r.vehicle_name).isoformat() if self.departure_store else None` to each vehicle entry.
   - Add `"urgency_reason": self._urgency_reason(r, now)` — a new short German text explaining the score.

5. Add `_urgency_reason(self, req: ChargeRequest, now: datetime) -> str` helper:
   - Get departure time and hours_remaining (same as _urgency_score).
   - Compute soc_deficit.
   - If departure is from DepartureTimeStore (not default): `f"Abfahrt in {hours_remaining:.0f}h, SoC {req.current_soc:.0f}%"`.
   - If departure is config default: `f"Standard-Abfahrt {self.departure_store._default_hour}:00, SoC {req.current_soc:.0f}%"` (or similar).
   - If no departure_store: `f"SoC {req.current_soc:.0f}%, Bedarf {soc_deficit:.0f}%"`.

**main.py — Wire DepartureTimeStore into ChargeSequencer:**

After creating departure_store and sequencer in main.py initialization:
- `sequencer.departure_store = departure_store` (late-assignment, same pattern as other injections).
- This must happen AFTER both departure_store and sequencer are created.
  </action>
  <verify>
    <automated>cd evcc-smartload && python -c "
import sys; sys.path.insert(0, 'rootfs/app')
import types; lm = types.ModuleType('logging_util'); lm.log = lambda *a: None; sys.modules['logging_util'] = lm
# Mock numpy
nm = types.ModuleType('numpy'); nm.array = lambda x: x; nm.float64 = float; sys.modules['numpy'] = nm
from charge_sequencer import ChargeSequencer
cs = ChargeSequencer.__new__(ChargeSequencer)
assert hasattr(cs, '_urgency_score') or callable(getattr(ChargeSequencer, '_urgency_score', None)), 'Missing _urgency_score method'
print('ChargeSequencer has urgency scoring')
print('ALL CHECKS PASSED')
"</automated>
    <manual>Verify _rank_vehicles uses urgency formula. Verify connected vehicle tie-break preserved. Verify quiet hours absolute priority preserved.</manual>
  </verify>
  <done>ChargeSequencer._rank_vehicles() uses urgency scoring (SoC deficit / hours to departure). Connected vehicle tie-break (+5.0) and quiet hours absolute priority (+1000.0) preserved. get_requests_summary() includes urgency_score, departure_time, and urgency_reason per vehicle.</done>
</task>

<task type="auto">
  <name>Task 2: Dashboard vehicle cards with urgency score and priority order</name>
  <files>
    evcc-smartload/rootfs/app/web/static/app.js
  </files>
  <action>
In `app.js`, find the section that renders vehicle/sequencer information on the Status tab (likely `renderSequencer()` or `renderDevice()` — check existing code).

1. **Urgency score display on vehicle cards:**
   - For each vehicle in the sequencer response, display the urgency information from the API:
   - Show urgency score prominently: `"Dringlichkeit: {urgency_score}"` (e.g., "Dringlichkeit: 4.2").
   - Show the natural language reason in parentheses: `"(Abfahrt in 3h, SoC 45%)"` — this comes from the `urgency_reason` field.
   - Show departure time if known: `"Abfahrt: {formatted_time}"`.
   - Per locked decision in CONTEXT.md: both the score number AND the natural language reason must be visible.

2. **Priority order indication:**
   - Sort vehicle cards by urgency_score descending (highest urgency first) when rendering.
   - Add a visual priority indicator: e.g., a numbered badge ("1.", "2.") or a "Prioritaet 1" / "Prioritaet 2" label on each card.
   - The exact visual pattern is at Claude's discretion per CONTEXT.md. A simple numbered prefix or subtle badge is sufficient.

3. **Conditional rendering:**
   - Only show urgency information when there are 2+ vehicles in the sequencer (single-vehicle case: urgency is irrelevant).
   - If urgency_score is 0 (no deficit), show "Voll geladen" or similar instead of the score.

4. **Integration with existing card structure:**
   - The urgency display should integrate cleanly with the existing vehicle card layout — do NOT rebuild the card structure.
   - Add urgency info as a new row/section within the existing card, below the SoC and status information.
   - Use the existing CSS class patterns for consistent styling.

Use `var` declarations (no let/const) for ES5 compatibility, matching the existing codebase style established in Phase 6.
  </action>
  <verify>
    <automated>cd evcc-smartload && grep -c "urgency_score\|urgency_reason\|Dringlichkeit\|departure_time" rootfs/app/web/static/app.js && echo "URGENCY UI PATTERNS FOUND"</automated>
    <manual>Check vehicle cards show urgency score with German label and natural language reason. Check priority ordering. Check single-vehicle case hides urgency.</manual>
  </verify>
  <done>Dashboard vehicle cards display urgency score ("Dringlichkeit: 4.2"), natural language reason ("Abfahrt in 3h, SoC 45%"), and departure time. Cards sorted by priority. Priority numbering visible when 2+ vehicles present.</done>
</task>

</tasks>

<verification>
1. `charge_sequencer.py` has _urgency_score() method with SoC-deficit/hours-to-departure formula
2. `_rank_vehicles()` uses urgency scoring instead of old point system
3. Connected vehicle tie-break (+5.0) and quiet hours rule (+1000.0) preserved
4. `get_requests_summary()` returns urgency_score, departure_time, urgency_reason per vehicle
5. `main.py` injects departure_store into sequencer
6. `app.js` shows urgency info on vehicle cards with German labels
7. Vehicle cards sorted by priority when 2+ vehicles present
</verification>

<success_criteria>
- Vehicle departing in 2h at 50% SoC gets higher urgency than one at 40% SoC departing in 12h (30/2=15 vs 40/12=3.3)
- Dashboard shows "Dringlichkeit: 15.0 (Abfahrt in 2h, SoC 50%)" on the urgent vehicle card
- Priority order visible on dashboard: urgent vehicle is card #1
- Connected vehicle tie-break prevents unnecessary wallbox swaps
- Quiet hours rule preserved: connected vehicle always wins during quiet hours
- Past departure times treated as no-deadline (12h default window)
</success_criteria>

<output>
After completion, create `.planning/phases/07-driver-interaction/07-03-SUMMARY.md`
</output>

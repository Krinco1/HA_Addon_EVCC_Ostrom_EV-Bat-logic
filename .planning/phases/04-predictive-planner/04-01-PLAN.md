---
phase: 04-predictive-planner
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - evcc-smartload/Dockerfile
  - evcc-smartload/rootfs/app/state.py
  - evcc-smartload/rootfs/app/optimizer/__init__.py
  - evcc-smartload/rootfs/app/optimizer/planner.py
autonomous: true
requirements: [PLAN-01]

must_haves:
  truths:
    - "HorizonPlanner.plan() returns a PlanHorizon with 96 DispatchSlots when given valid price, consumption, and PV arrays"
    - "LP solver completes in under 10 seconds with time_limit enforced"
    - "PlanHorizon contains per-slot battery charge/discharge kW and EV charge kW decisions"
    - "When solver fails (status != 0), plan() returns None (not a partial result)"
    - "scipy is importable inside the Docker container (apk install, not pip)"
  artifacts:
    - path: "evcc-smartload/rootfs/app/optimizer/planner.py"
      provides: "HorizonPlanner class with LP formulation and MPC loop"
      min_lines: 200
    - path: "evcc-smartload/rootfs/app/state.py"
      provides: "PlanHorizon and DispatchSlot dataclasses"
      contains: "class PlanHorizon"
    - path: "evcc-smartload/Dockerfile"
      provides: "py3-scipy Alpine package installation"
      contains: "py3-scipy"
  key_links:
    - from: "evcc-smartload/rootfs/app/optimizer/planner.py"
      to: "scipy.optimize.linprog"
      via: "LP solver call with method='highs'"
      pattern: "linprog.*method.*highs"
    - from: "evcc-smartload/rootfs/app/optimizer/planner.py"
      to: "evcc-smartload/rootfs/app/state.py"
      via: "imports PlanHorizon, DispatchSlot for return type"
      pattern: "from state import.*PlanHorizon"
---

<objective>
Implement the core HorizonPlanner LP engine with scipy/HiGHS and the PlanHorizon/DispatchSlot data structures.

Purpose: This is the foundation of Phase 4 — the LP formulation that produces a 24-48h joint battery and EV dispatch plan from price, consumption, and PV forecast inputs. Without this, no predictive planning can occur.

Output: `optimizer/planner.py` with a working `HorizonPlanner.plan()` method that takes current system state and forecast arrays, builds the LP constraint matrix, solves via HiGHS, and returns a `PlanHorizon` with 96 `DispatchSlot` objects.
</objective>

<execution_context>
@C:/Users/nicok/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/nicok/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-predictive-planner/04-RESEARCH.md

# Key source files to reference for existing patterns:
@evcc-smartload/rootfs/app/state.py
@evcc-smartload/rootfs/app/optimizer/holistic.py
@evcc-smartload/rootfs/app/optimizer/__init__.py
@evcc-smartload/rootfs/app/config.py
@evcc-smartload/rootfs/app/forecaster/consumption.py
@evcc-smartload/Dockerfile
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add scipy to Dockerfile and create PlanHorizon/DispatchSlot dataclasses</name>
  <files>evcc-smartload/Dockerfile, evcc-smartload/rootfs/app/state.py</files>
  <action>
**Dockerfile:** Add `py3-scipy` to the Alpine `apk add` line in the Dockerfile. Do NOT use `pip install scipy` — use `apk add --no-cache py3-scipy`. This pre-compiled musl-compatible package includes HiGHS and openblas automatically.

**state.py:** Add two new dataclasses at the end of the file (after the existing Action class):

```python
@dataclass
class DispatchSlot:
    """Decision for one 15-min slot in the horizon."""
    slot_index: int              # 0..95 (0 = current slot)
    slot_start: datetime         # UTC timestamp of slot start
    bat_charge_kw: float         # kW battery charges from grid (0 if not charging)
    bat_discharge_kw: float      # kW battery discharges to home (0 if not discharging)
    ev_charge_kw: float          # kW EV charges from grid (0 if not charging)
    ev_name: str                 # which EV (empty string if no EV)
    price_eur_kwh: float         # grid price for this slot
    pv_kw: float                 # PV generation forecast for this slot
    consumption_kw: float        # expected house consumption for this slot (kW)
    bat_soc_pct: float           # battery SoC at start of slot (% from LP)
    ev_soc_pct: float            # EV SoC at start of slot (% from LP)

@dataclass
class PlanHorizon:
    """Complete rolling-horizon plan for the next 24h."""
    computed_at: datetime        # when this plan was computed (UTC)
    slots: List[DispatchSlot]    # 96 slots (or fewer if price data short)
    solver_status: int           # linprog result.status (0=optimal)
    solver_fun: float            # objective value (total cost in EUR)
    current_bat_charge: bool     # True if battery should charge this slot
    current_bat_discharge: bool  # True if battery should discharge this slot
    current_ev_charge: bool      # True if EV should charge this slot
    current_price_limit: float   # effective price limit for this slot (EUR/kWh)
```

Add necessary imports: `from typing import List` (if not already present) and `from datetime import datetime`.
  </action>
  <verify>
1. Run `docker build` to confirm Dockerfile builds (or verify `apk add py3-scipy` line exists in Dockerfile)
2. Confirm `PlanHorizon` and `DispatchSlot` classes exist in state.py with all fields
3. Confirm state.py has no syntax errors: `python -c "from state import PlanHorizon, DispatchSlot"` (from app/ directory)
  </verify>
  <done>
- Dockerfile includes `py3-scipy` via apk (not pip)
- state.py defines PlanHorizon and DispatchSlot dataclasses with all fields from research spec
- No imports broken in existing state.py consumers
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement HorizonPlanner LP formulation with scipy/HiGHS</name>
  <files>evcc-smartload/rootfs/app/optimizer/planner.py, evcc-smartload/rootfs/app/optimizer/__init__.py</files>
  <action>
Create `optimizer/planner.py` containing the `HorizonPlanner` class. Follow the Research patterns exactly (Pattern 1-3).

**Class structure:**

```python
class HorizonPlanner:
    def __init__(self, cfg: Config):
        # Store config values needed for LP: battery_capacity_kwh, battery_charge_power_kw,
        # battery_charge_efficiency, battery_discharge_efficiency, battery_min_soc, battery_max_soc,
        # feed_in_eur_per_kwh (from cfg or default 0.08), ev_max_price_ct, battery_max_price_ct
        # T = 96 (15-min slots in 24h)

    def plan(self, state, tariffs, consumption_96, pv_96, ev_departure_times) -> Optional[PlanHorizon]:
        # 1. Convert tariffs to 96-slot price array via _tariffs_to_96slots()
        # 2. If price array is None (< 32 slots available), return None
        # 3. Call _solve_lp() with all inputs
        # 4. If solver fails (result is None or not success), log warning, return None
        # 5. Call _extract_plan() to build PlanHorizon from result.x
        # 6. Wrap entire method in try/except, return None on any exception

    def _tariffs_to_96slots(self, tariffs, now) -> Optional[np.ndarray]:
        # Reuse existing _tariffs_to_hourly() parsing logic from HolisticOptimizer
        # Each hour -> 4 x 15-min slots
        # If < 32 slots available, return None (insufficient horizon)
        # Pad to 96 with last known price if between 32 and 96 slots

    def _solve_lp(self, state, price_96, consumption_96, pv_96, ev_departure_times):
        # Build LP variable layout (Research Pattern 1):
        # - T = min(96, len(price_96))
        # - i_bat_chg, i_bat_dis, i_ev_chg, i_bat_soc, i_ev_soc index offsets
        # - N_vars = 3*T + 2*(T+1)
        #
        # Build objective c:
        # - Grid cost for bat_charge and ev_charge: price_eur_per_kwh[t]
        # - Account for PV surplus: pv_surplus_kw[t] = max(0, pv_96[t] - consumption_96[t]/1000)
        #   Reduce effective grid cost when PV surplus covers charging (Research Pitfall 3)
        # - Revenue from bat_discharge: -feed_in_eur_per_kwh
        #
        # Build equality constraints (SoC dynamics):
        # - Battery: soc[t+1] = soc[t] + charge[t]*eta_c*dt/cap - discharge[t]*dt/(eta_d*cap)
        # - Initial battery SoC: soc[0] = state.battery_soc / 100
        # - EV: soc[t+1] = soc[t] + charge[t]*dt/ev_cap (if connected)
        # - Initial EV SoC: soc[0] = state.ev_soc / 100 (if connected)
        #
        # Build inequality constraints:
        # - Departure constraint: ev_soc[departure_slot] >= target_soc/100
        #   Written as: -ev_soc[departure_slot] <= -target_soc/100
        # - Mutual exclusion guard: bat_charge[t] + bat_discharge[t] <= max(P_charge, P_discharge)
        #   (Research Open Question 1 recommendation — prevents degeneracy at unit efficiency)
        #
        # Build bounds:
        # - bat_charge: (0, battery_charge_power_kw)
        # - bat_discharge: (0, battery_charge_power_kw)
        # - ev_charge: (0, ev_charge_power_kw) if connected, else (0, 0)
        # - bat_soc: (battery_min_soc/100, battery_max_soc/100)
        # - ev_soc: (0, 1.0) if connected, else (0, 0)
        #
        # EV capacity/power: use state.ev_capacity_kwh or cfg.ev_default_energy_kwh,
        #   state.ev_charge_power_kw or cfg.sequencer_default_charge_power_kw
        #   (Research Open Question 2 — follow existing HolisticOptimizer fallback pattern)
        #
        # Use upper bounds from config: battery_max_price_ct/100 as max price for battery,
        #   ev_max_price_ct/100 as max price for EV (these are LP input bounds, not price gates)
        #
        # Solve:
        # from scipy.optimize import linprog
        # result = linprog(c, A_ub=A_ub, b_ub=b_ub, A_eq=A_eq, b_eq=b_eq, bounds=bounds,
        #                  method='highs', options={'time_limit': 10.0, 'disp': False, 'presolve': True})
        #
        # IMPORTANT: Build A_eq and A_ub as numpy 2D arrays directly (not row-by-row lists then convert).
        # Use pre-allocated np.zeros((n_rows, N_vars)) and fill via index arithmetic.
        #
        # Return result if status == 0 and success, else return None

    def _extract_plan(self, result, price_96, state, consumption_96, pv_96, ev_departure_times, now) -> PlanHorizon:
        # Clip all extracted values: np.clip(result.x[start:end], 0, power_max)
        # (Research Pitfall 5 — numerical precision may produce tiny negatives)
        # Build 96 DispatchSlot objects from LP result variables
        # Determine current slot actions (slot 0) for current_bat_charge, current_bat_discharge, current_ev_charge
        # Use 0.1 kW threshold for boolean decisions
        # Return PlanHorizon with all fields populated

    @staticmethod
    def _departure_slot(departure_dt, now) -> int:
        # Same pattern as Research code example
        # delta_minutes = (departure_dt - now).total_seconds() / 60
        # slot_offset = int(delta_minutes / 15)
        # return max(1, min(95, slot_offset))
```

**Important implementation notes:**
- Import `from scipy.optimize import linprog` inside `_solve_lp()` (lazy import — avoids import error if scipy missing until planner actually called).
- Use `numpy` for all matrix operations (already installed).
- Do NOT use sparse matrices — at T=96 the matrices are small (~800KB dense). Research explicitly advises against sparse.
- Handle "no EV connected" case: when `state.ev_connected == False`, set all ev_charge bounds to (0,0), skip departure constraints, set ev_soc dynamics to identity.
- Pre-check infeasibility for EV departure constraint before solving: if `(departure_slots * ev_charge_power * dt_h / ev_capacity) < (target_soc - current_soc) / 100`, log warning and either relax target or fall back.
- Log solver time: `log("info", f"HorizonPlanner: LP solved in {elapsed:.1f}s, status={result.status}, cost={result.fun:.4f} EUR")`

**Update `optimizer/__init__.py`:** Add `HorizonPlanner` to the exports alongside existing `HolisticOptimizer` and `EventDetector`.
  </action>
  <verify>
1. `python -c "from optimizer.planner import HorizonPlanner"` succeeds from app/ directory
2. `optimizer/__init__.py` exports HorizonPlanner
3. planner.py has all methods: plan(), _tariffs_to_96slots(), _solve_lp(), _extract_plan(), _departure_slot()
4. planner.py does NOT import scipy at module level (lazy import inside _solve_lp)
5. planner.py handles ev_connected=False case (no EV constraints when disconnected)
6. planner.py uses np.clip on extracted LP result values
  </verify>
  <done>
- HorizonPlanner.plan() accepts state, tariffs, consumption_96, pv_96, ev_departure_times and returns Optional[PlanHorizon]
- LP formulation uses scipy.optimize.linprog with method='highs' and time_limit=10.0
- 96-slot variable layout: bat_charge, bat_discharge, ev_charge, bat_soc, ev_soc (N_vars = 5T+2 = 482)
- SoC dynamics as equality constraints, departure time as inequality constraint
- Returns None on any solver failure, insufficient price data, or exception
- No EV case handled: ev_charge bounds clamped to 0, no departure constraint
  </done>
</task>

</tasks>

<verification>
1. `from optimizer.planner import HorizonPlanner` imports without error
2. `from state import PlanHorizon, DispatchSlot` imports without error
3. Dockerfile includes `py3-scipy` via `apk add`
4. `optimizer/__init__.py` exports HorizonPlanner
5. HorizonPlanner constructor accepts Config object
6. HorizonPlanner.plan() returns Optional[PlanHorizon] (None on failure, PlanHorizon on success)
</verification>

<success_criteria>
- HorizonPlanner can be instantiated with a Config object
- Calling plan() with valid inputs produces a PlanHorizon with 96 DispatchSlots
- Calling plan() with bad inputs (empty tariffs, short price array) returns None gracefully
- scipy is available via apk in the Docker container
- No existing imports or classes in state.py or optimizer/ are broken
</success_criteria>

<output>
After completion, create `.planning/phases/04-predictive-planner/04-01-SUMMARY.md`
</output>

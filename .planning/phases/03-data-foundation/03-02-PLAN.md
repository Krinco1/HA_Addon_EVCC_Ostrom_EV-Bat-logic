---
phase: 03-data-foundation
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - evcc-smartload/rootfs/app/forecaster/pv.py
  - evcc-smartload/rootfs/app/forecaster/__init__.py
autonomous: true
requirements: [PLAN-05]

must_haves:
  truths:
    - "PVForecaster returns 96-slot list of kW values for the next 24h derived from evcc solar tariff API"
    - "Partial forecasts (<24h data) reduce confidence proportionally (12h = 0.5)"
    - "Total API failure results in 0 kWh generation assumption (conservative and safe)"
    - "Correction coefficient tracks actual vs forecast PV and persists across restarts"
    - "Correction coefficient only updates during daytime (forecast > 50 W threshold)"
    - "Human-readable correction label available (e.g., 'Korrektur: +13%')"
    - "Human-readable forecast quality label available (e.g., 'Basierend auf 18h Forecast-Daten')"
  artifacts:
    - path: "evcc-smartload/rootfs/app/forecaster/pv.py"
      provides: "PV generation forecaster with correction coefficient"
      min_lines: 120
    - path: "evcc-smartload/rootfs/app/forecaster/__init__.py"
      provides: "Package exports for ConsumptionForecaster and PVForecaster"
      contains: "PVForecaster"
  key_links:
    - from: "evcc-smartload/rootfs/app/forecaster/pv.py"
      to: "evcc-smartload/rootfs/app/evcc_client.py"
      via: "evcc_client.get_tariff_solar() call during hourly refresh"
      pattern: "get_tariff_solar"
    - from: "evcc-smartload/rootfs/app/forecaster/pv.py"
      to: "/data/smartprice_pv_model.json"
      via: "JSON atomic write for correction coefficient persistence"
      pattern: "os\\.rename"
---

<objective>
Build the PVForecaster module that provides per-slot (15-min) PV generation forecasts from the evcc solar tariff API, with correction coefficient tracking and partial forecast handling.

Purpose: PLAN-05 requires PV generation estimates from the evcc solar tariff API integrated into planning inputs. This plan creates the standalone PV forecaster with confidence tracking and correction coefficient, ready to be wired into the main loop by Plan 03.

Output: `forecaster/pv.py` module with PVForecaster class, updated package exports.
</objective>

<execution_context>
@C:/Users/nicok/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/nicok/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-data-foundation/03-RESEARCH.md
@.planning/phases/03-data-foundation/03-CONTEXT.md

@evcc-smartload/rootfs/app/evcc_client.py
@evcc-smartload/rootfs/app/state.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: PVForecaster with evcc solar tariff integration and correction coefficient</name>
  <files>
    evcc-smartload/rootfs/app/forecaster/pv.py
    evcc-smartload/rootfs/app/forecaster/__init__.py
  </files>
  <action>
**1. `forecaster/pv.py` — PVForecaster class:**

Constants:
- `PV_MODEL_PATH = "/data/smartprice_pv_model.json"`
- `PV_MODEL_VERSION = 1`
- `DAYTIME_THRESHOLD_W = 50` — minimum forecast watts to update correction coefficient (Research Pitfall 7: avoid nighttime drift)

Constructor `__init__(self, evcc_client)`:
- Store reference to evcc_client
- `_slots = []` — list of parsed forecast slots (each: `{"start": datetime, "end": datetime, "kw": float}`)
- `_correction = 1.0` — rolling actual/forecast ratio
- `_coverage_hours = 0` — how many future hours have forecast data
- `_lock = threading.Lock()` for concurrent read/write protection
- `_last_refresh = None` — datetime of last successful API fetch
- Call `_load()` to restore correction coefficient from persistent storage

**Core methods:**

`refresh(self)`:
- Called hourly (per user decision: PV forecast refreshed hourly from evcc API)
- Call `self._evcc.get_tariff_solar()` — returns list of `{"start": str, "end": str, "value": float}` dicts
- If returns empty list: set `_coverage_hours = 0`, log warning "PV forecast: evcc solar API returned no data", return (total failure case: planner uses 0 kWh — conservative and safe per user decision)
- Parse slots: for each rate, parse ISO8601 start/end timestamps, compute slot duration `(end - start).total_seconds() / 3600` (Research open question 4: do NOT assume fixed slot size)
- CRITICAL UNIT HANDLING (Research Pitfall 1): Reuse the existing unit detection heuristic from `state.py:calc_solar_surplus_kwh()`:
  - If median value > 100, treat as Watts (Forecast.Solar/Open-Meteo): multiply by 0.001 to get kW
  - If median value <= 100, treat as kW already
  - Then `kwh_per_slot = kw * slot_duration_hours`
- Count future slots to determine `_coverage_hours`: count slots where `start > now`
- Store parsed slots under lock
- Set `_last_refresh = datetime.now(timezone.utc)`
- Call `_save()` to persist correction coefficient
- Log: "PV forecast: {_coverage_hours}h coverage, correction={_correction:.2f}"

`get_forecast_24h(self) -> list`:
- Under lock, return 96 kW values for next 24h in 15-min resolution
- Interpolate hourly evcc data to 15-min slots: for each evcc slot, distribute its kW value evenly across the 15-min sub-slots it covers
- Apply correction coefficient: `kw * self._correction` for each slot
- For time ranges beyond the forecast data: return 0.0 (conservative)
- If no forecast data at all: return list of 96 zeros

`update_correction(self, actual_pv_kw: float, timestamp: datetime)`:
- Called every 15-min decision cycle with actual PV power reading from state.pv_power
- Per user decision: actual PV output continuously compared against forecast to derive correction coefficient
- Look up the forecast value for the current time slot
- ONLY update correction when forecast value > DAYTIME_THRESHOLD_W (converted to kW) — skip night hours entirely (Research Pitfall 7)
- Use EMA for correction: `self._correction = 0.9 * self._correction + 0.1 * (actual / forecast)`
- Clamp to [0.3, 3.0] range — PV can legitimately be 3x forecast (unexpectedly sunny) or 0.3x (heavy cloud)

**Properties:**

`confidence` property -> float:
- `0.0` to `1.0` based on coverage: `min(1.0, self._coverage_hours / 24.0)`
- Per user decision: reduced confidence proportional to data coverage (12h = 50% confidence)

`correction_label` property -> str:
- Human-readable: "Korrektur: +13%" or "Korrektur: -8%"
- Per user decision: shown on dashboard as subtle info below PV graph

`quality_label` property -> str:
- Human-readable: "Basierend auf {_coverage_hours}h Forecast-Daten"
- Per user decision: PV forecast quality displayed subtly below graph
- When coverage is 0: "Kein PV-Forecast verfuegbar"

`coverage_hours` property -> int:
- Returns `_coverage_hours` for external consumers

**Persistence:**

`_load(self)`:
- Load `PV_MODEL_PATH` if exists
- Check version == PV_MODEL_VERSION
- Restore `_correction` only (forecast data is ephemeral — re-fetched hourly)
- On version mismatch or missing file: use default correction = 1.0

`_save(self)`:
- Atomic JSON write (same pattern as ConsumptionForecaster): write to `.tmp` then `os.rename()`
- Store `version`, `correction`, `last_refresh` (ISO8601 string)

**2. `forecaster/__init__.py` — update exports:**
- Read the existing `__init__.py` (created by Plan 01)
- Add `from .pv import PVForecaster` export
- File should export both `ConsumptionForecaster` and `PVForecaster`

IMPORTANT: Do NOT treat evcc solar tariff values as kWh — they are Watts (Research Pitfall 1). Always compute `kw = value * unit_factor`, then `kwh = kw * slot_duration_hours`. Do NOT apply correction coefficient during night hours. Do NOT use plotly or any external charting library.
  </action>
  <verify>
1. grep for `PVForecaster` in `forecaster/__init__.py` confirms export
2. grep for `get_tariff_solar` in `forecaster/pv.py` confirms evcc API integration
3. grep for `DAYTIME_THRESHOLD` in `forecaster/pv.py` confirms nighttime correction guard
4. grep for `confidence` in `forecaster/pv.py` confirms coverage-based confidence property
5. grep for `correction_label` in `forecaster/pv.py` confirms German display label
6. grep for `quality_label` in `forecaster/pv.py` confirms forecast quality label
7. grep for `os.rename` in `forecaster/pv.py` confirms atomic write persistence
8. grep for `PV_MODEL_VERSION` in `forecaster/pv.py` confirms versioned persistence
9. grep for `0.001` or `unit` in `forecaster/pv.py` confirms Watt-to-kW unit handling
10. Confirm `forecaster/pv.py` is at least 120 lines
  </verify>
  <done>
PVForecaster class exists with: hourly evcc solar tariff refresh, Watt-to-kW unit detection (reusing existing heuristic), 15-min slot interpolation from hourly data, correction coefficient with EMA (daytime-only updates, Pitfall 7 avoided), coverage-based confidence (0-1.0), German labels for correction and quality, persistent versioned JSON at /data/, atomic write. Package __init__.py exports both ConsumptionForecaster and PVForecaster.
  </done>
</task>

</tasks>

<verification>
- `from forecaster import PVForecaster` importable
- PVForecaster.get_forecast_24h() returns 96-element list of kW values
- PVForecaster.confidence returns float 0.0-1.0
- PVForecaster.correction_label returns German string
- PVForecaster.quality_label returns German string
- Correction coefficient persists to /data/smartprice_pv_model.json
- No new dependencies (evcc_client already exists, aiohttp not needed for this plan)
</verification>

<success_criteria>
- PVForecaster correctly handles evcc solar tariff Watt values (not treating as kWh)
- Partial forecasts (e.g., 12h data) produce confidence = 0.5
- Total API failure produces 96 zeros and confidence = 0.0
- Correction coefficient only updates when forecast > 50W (daytime)
- Correction coefficient persists across restarts via atomic JSON write
- German labels match user-specified formats
</success_criteria>

<output>
After completion, create `.planning/phases/03-data-foundation/03-02-SUMMARY.md`
</output>

---
phase: 03-data-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - evcc-smartload/rootfs/app/forecaster/__init__.py
  - evcc-smartload/rootfs/app/forecaster/consumption.py
  - evcc-smartload/rootfs/app/forecaster/ha_energy.py
  - evcc-smartload/rootfs/app/influxdb_client.py
  - evcc-smartload/rootfs/app/config.py
autonomous: true
requirements: [PLAN-04]

must_haves:
  truths:
    - "ConsumptionForecaster returns 96-slot list of estimated Watt values for the next 24h"
    - "InfluxDB home_power history is queried at 15-min resolution for the last 7 days"
    - "Forecaster model persists to /data/smartprice_consumption_model.json and survives restarts"
    - "On schema version mismatch, model is cleared and rebuilt from InfluxDB source data"
    - "HA energy entity discovery warns about unconfigured energy entities via log and returns entity list"
    - "Cold start with no data returns is_ready=False and get_forecast_24h returns DEFAULT_WATTS for all slots"
    - "Immediate self-correction: when actual load deviates from forecast, correction_factor adjusts current-hour weighting"
  artifacts:
    - path: "evcc-smartload/rootfs/app/forecaster/__init__.py"
      provides: "Package exports for ConsumptionForecaster"
      contains: "ConsumptionForecaster"
    - path: "evcc-smartload/rootfs/app/forecaster/consumption.py"
      provides: "Hour-of-day rolling average forecaster with tiered aggregation"
      min_lines: 150
    - path: "evcc-smartload/rootfs/app/forecaster/ha_energy.py"
      provides: "HA WebSocket energy entity discovery with REST fallback"
      min_lines: 60
    - path: "evcc-smartload/rootfs/app/influxdb_client.py"
      provides: "query_home_power_15min() method for 15-min resolution history"
      contains: "query_home_power_15min"
    - path: "evcc-smartload/rootfs/app/config.py"
      provides: "ha_url and ha_token optional config fields"
      contains: "ha_url"
  key_links:
    - from: "evcc-smartload/rootfs/app/forecaster/consumption.py"
      to: "evcc-smartload/rootfs/app/influxdb_client.py"
      via: "query_home_power_15min() call during bootstrap and periodic rebuild"
      pattern: "query_home_power_15min"
    - from: "evcc-smartload/rootfs/app/forecaster/ha_energy.py"
      to: "HA WebSocket API"
      via: "aiohttp ws_connect for energy/get_prefs"
      pattern: "energy/get_prefs"
    - from: "evcc-smartload/rootfs/app/forecaster/consumption.py"
      to: "/data/smartprice_consumption_model.json"
      via: "JSON atomic write (write to .tmp then os.rename)"
      pattern: "os\\.rename"
---

<objective>
Build the ConsumptionForecaster module that provides per-slot (15-min) house consumption forecasts from InfluxDB history, with HA energy entity discovery for validation.

Purpose: PLAN-04 requires house consumption to be forecast from HA/InfluxDB history rather than fixed defaults. This plan creates the standalone forecaster module and its data sources, ready to be wired into the main loop by Plan 03.

Output: `forecaster/` package with ConsumptionForecaster and ha_energy modules, extended InfluxDB client with 15-min query, HA config fields.
</objective>

<execution_context>
@C:/Users/nicok/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/nicok/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-data-foundation/03-RESEARCH.md
@.planning/phases/03-data-foundation/03-CONTEXT.md
@.planning/phases/01-state-infrastructure/01-01-SUMMARY.md

@evcc-smartload/rootfs/app/influxdb_client.py
@evcc-smartload/rootfs/app/config.py
@evcc-smartload/rootfs/app/state_store.py
@evcc-smartload/rootfs/app/logging_util.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: ConsumptionForecaster with tiered aggregation and persistent model</name>
  <files>
    evcc-smartload/rootfs/app/forecaster/__init__.py
    evcc-smartload/rootfs/app/forecaster/consumption.py
    evcc-smartload/rootfs/app/influxdb_client.py
    evcc-smartload/rootfs/app/config.py
  </files>
  <action>
Create the `forecaster/` package directory at `evcc-smartload/rootfs/app/forecaster/`.

**1. `forecaster/__init__.py`:**
Export `ConsumptionForecaster` from `.consumption`. Keep minimal — PVForecaster will be added by Plan 02.

**2. `forecaster/consumption.py` — ConsumptionForecaster class:**

Constants:
- `MODEL_PATH = "/data/smartprice_consumption_model.json"`
- `MODEL_VERSION = 1`
- `SLOTS_PER_DAY = 96` (24h x 4 slots/h)
- `DEFAULT_WATTS = 1200` (sensible cold-start default)

Constructor `__init__(self, influx_client, cfg)`:
- Store references to influx client and config
- Initialize `_slot_sums` (96 floats), `_slot_counts` (96 ints), `_correction_factor = 1.0`
- `_data_days = 0` tracking how many days of real data exist
- `_lock = threading.Lock()` for concurrent read/write protection
- Call `_load_or_init()` to load from persistent storage or bootstrap from InfluxDB

**Tiered aggregation scheme (user locked: tiered with Claude deciding specifics):**
- **Last 7 days:** Query InfluxDB with `query_home_power_15min(days=7)` for full 15-min resolution. Weight = 1.0 per observation.
- **Days 8-30:** Query InfluxDB with a new `query_home_power_hourly(days_start=8, days_end=30)` using `GROUP BY time(1h)`. Each hourly value contributes to its 4 constituent 15-min slots with weight = 0.5.
- **Beyond 30 days:** Day-of-week profiles from InfluxDB `GROUP BY time(1d)` mapped to 24 hourly buckets. Weight = 0.25. These serve as baseline.

`_load_or_init()`:
- Try to load `MODEL_PATH`. If file exists and `model["version"] == MODEL_VERSION`, restore `_slot_sums`, `_slot_counts`, `_data_days`, `_correction_factor` from JSON.
- If version mismatch: log "Schema upgrade detected, rebuilding model from InfluxDB", call `_bootstrap_from_influxdb()`.
- If file missing: call `_bootstrap_from_influxdb()`.

`_bootstrap_from_influxdb()`:
- Call `self._influx.query_home_power_15min(days=7)` for recent tier
- For each result row, compute slot index via `_slot_index(timestamp)`, accumulate into `_slot_sums[slot]` and `_slot_counts[slot]` with weight 1.0
- Call `self._influx.query_home_power_hourly(days_start=8, days_end=30)` for medium tier
- For each hourly value, distribute to 4 slots with weight 0.5
- Estimate `_data_days` from the span of returned data
- Call `_save()` to persist

`_slot_index(ts: datetime) -> int`:
- `return (ts.hour * 60 + ts.minute) // 15`

`get_forecast_24h(self) -> list`:
- Under lock, starting from current slot index, return 96 values
- For slots with data (`_slot_counts[slot] > 0`): return `(_slot_sums[slot] / _slot_counts[slot]) * _correction_factor`
- For slots without data: return `DEFAULT_WATTS`

`update(self, current_watts: float, timestamp: datetime)`:
- Called every 15-min decision cycle with actual home_power reading
- Under lock, use EMA with alpha=0.1: if slot has no data, initialize directly; otherwise compute `new_avg = (1 - alpha) * old_avg + alpha * current_watts` and store normalized (sum = new_avg, count = 1)
- Increment `_data_days` based on unique days seen (track `_seen_days: set`)
- Call `_save()` after update (use a save-interval: save every 4th update = hourly, not every 15 min)

`apply_correction(self, actual_watts: float, forecast_watts: float)`:
- Per user decision: immediate self-correction when actual deviates from forecast
- Only apply when forecast > 100 W (avoid division by near-zero)
- Clamp correction factor to [0.5, 1.5] range: `self._correction_factor = max(0.5, min(1.5, actual_watts / forecast_watts))`

`is_ready` property:
- Returns True only after at least 24h of data (`_data_days >= 1`)
- Before that, downstream callers should use defaults and log readiness status

`data_days` property:
- Returns `_data_days` for dashboard maturity display

`_save(self)`:
- Atomic JSON write: write to `MODEL_PATH + ".tmp"`, then `os.rename()` (atomic on Linux/Alpine)
- Include `version`, `slot_sums`, `slot_counts`, `data_days`, `correction_factor` in model dict

**3. `influxdb_client.py` — extend with two new query methods:**

`query_home_power_15min(self, days: int = 7) -> list`:
- If not `_enabled`, return `[]`
- InfluxQL: `SELECT mean(home_power) FROM Smartprice WHERE time > now() - {days}d GROUP BY time(15m) fill(none)`
- Parse response using exact same pattern as `get_history_hours()`: iterate `data["results"][0]["series"][0]["values"]`
- Return list of `{"time": row[0], "watts": float(row[1])}` dicts
- Wrap in try/except, log warning on failure, return `[]`

`query_home_power_hourly(self, days_start: int = 8, days_end: int = 30) -> list`:
- If not `_enabled`, return `[]`
- InfluxQL: `SELECT mean(home_power) FROM Smartprice WHERE time > now() - {days_end}d AND time <= now() - {days_start}d GROUP BY time(1h) fill(none)`
- Same response parsing pattern
- Return list of `{"time": row[0], "watts": float(row[1])}` dicts

**4. `config.py` — add optional HA config fields:**
- Add `ha_url: str = ""` and `ha_token: str = ""` to the Config dataclass alongside other optional integration fields
- These are used by `ha_energy.py` for HA WebSocket entity discovery
- Also check `os.environ.get("SUPERVISOR_TOKEN")` — if present inside HA add-on, auto-populate `ha_url = "http://supervisor/core"` and `ha_token` from env var (see Research open question 1)

IMPORTANT: Do NOT use plotly, Chart.js, or any external charting library. Do NOT implement weekday/weekend separation (Claude's discretion: single unified profile first, per Research recommendation). Do NOT implement Grossverbraucher patterns or Telegram push (deferred).
  </action>
  <verify>
Verify the following file structure and content:
1. `ls evcc-smartload/rootfs/app/forecaster/` shows `__init__.py`, `consumption.py`
2. grep for `ConsumptionForecaster` in `forecaster/__init__.py` confirms export
3. grep for `query_home_power_15min` in `influxdb_client.py` confirms new method exists
4. grep for `query_home_power_hourly` in `influxdb_client.py` confirms new method exists
5. grep for `ha_url` in `config.py` confirms new config fields
6. grep for `MODEL_VERSION` in `forecaster/consumption.py` confirms versioned persistence
7. grep for `os.rename` in `forecaster/consumption.py` confirms atomic write pattern
8. grep for `is_ready` in `forecaster/consumption.py` confirms readiness property
9. grep for `apply_correction` in `forecaster/consumption.py` confirms self-correction method
10. Confirm `forecaster/consumption.py` is at least 150 lines
  </verify>
  <done>
ConsumptionForecaster class exists with: 96-slot EMA model, tiered InfluxDB bootstrap (7d@15min, 8-30d@1h), persistent versioned JSON model at /data/, atomic write, is_ready gate, apply_correction self-correction, threading.Lock protection. InfluxDB client has query_home_power_15min() and query_home_power_hourly() methods. Config has optional ha_url/ha_token fields with SUPERVISOR_TOKEN auto-detection.
  </done>
</task>

<task type="auto">
  <name>Task 2: HA energy entity discovery with WebSocket and REST fallback</name>
  <files>
    evcc-smartload/rootfs/app/forecaster/ha_energy.py
  </files>
  <action>
Create `evcc-smartload/rootfs/app/forecaster/ha_energy.py` implementing HA energy entity discovery.

**Purpose:** Discover which energy entities are configured in HA's Energy Dashboard, and identify unconfigured entities that probably should be included. Per user decision: warning display both as dashboard banner AND detailed log entry with entity IDs.

**Implementation:**

`fetch_ha_energy_prefs(ha_url: str, token: str) -> dict`:
- Synchronous wrapper that runs async WebSocket call in a dedicated thread via `asyncio.run()`
- Returns the `energy_sources` result from HA, or `{}` on any failure
- Log warning on failure: `"HA energy/get_prefs failed: {e}"`

`_fetch_energy_prefs_async(ha_url: str, token: str) -> dict`:
- Async function using `aiohttp.ClientSession` (already in Dockerfile)
- Connect to WebSocket: convert `ha_url` http->ws, https->wss, append `/api/websocket`
- Auth protocol: receive `auth_required`, send `{"type": "auth", "access_token": token}`, verify `auth_ok`
- Send `{"id": 1, "type": "energy/get_prefs"}`, receive result
- Set `aiohttp.ClientTimeout(total=10)` to avoid hanging on unresponsive HA
- Return `result.get("result", {})`

`discover_configured_entities(prefs: dict) -> list`:
- Parse `prefs["energy_sources"]` looking for `type == "grid"` entries
- Extract `flow_from[].stat_energy_from` entity IDs (these are the configured consumption sensors)
- Also check `flow_to[].stat_energy_to` for solar feed-in entities
- Return sorted list of configured entity ID strings

`find_unconfigured_energy_entities(ha_url: str, token: str, configured: list) -> list`:
- Call HA REST API `GET {ha_url}/api/states` with `Authorization: Bearer {token}` header
- Filter states where `attributes.device_class == "energy"` and `attributes.state_class` in `["total", "total_increasing"]`
- Exclude entities already in `configured` list
- Return list of `{"entity_id": str, "friendly_name": str}` dicts for unconfigured entities

`run_entity_discovery(ha_url: str, token: str) -> dict`:
- Main entry point, called once at startup from a daemon thread
- Calls `fetch_ha_energy_prefs()` first (WebSocket)
- If WebSocket fails, log warning and return `{"configured": [], "unconfigured": [], "error": "WebSocket failed"}`
- On success: call `discover_configured_entities()` and `find_unconfigured_energy_entities()`
- If unconfigured entities found: log WARNING with each entity_id and friendly_name
  - Format: `"HA Energy Dashboard: {N} Energie-Entities nicht konfiguriert: {entity_ids}"`
  - Per user decision: this warning is displayed BOTH as dashboard banner AND log entry
- Return `{"configured": [...], "unconfigured": [...], "warnings": [...]}`

CRITICAL: Run the HA WebSocket call in a threading.Thread(daemon=True) at startup as per Research Pitfall 3. asyncio.run() in the main thread blocks the decision loop. Store result in a thread-safe dict. If HA is unreachable, log a warning and skip entity validation entirely (non-critical path).

Do NOT use synchronous WebSocket libraries. Use aiohttp which is already installed in the Alpine container.
  </action>
  <verify>
1. grep for `energy/get_prefs` in `forecaster/ha_energy.py` confirms WebSocket discovery
2. grep for `run_entity_discovery` in `forecaster/ha_energy.py` confirms main entry point
3. grep for `find_unconfigured_energy_entities` confirms REST fallback for entity comparison
4. grep for `daemon` or `Thread` in `forecaster/ha_energy.py` confirms non-blocking pattern awareness
5. grep for `nicht konfiguriert` confirms German warning message
6. Confirm file is at least 60 lines
  </verify>
  <done>
HA energy entity discovery module exists with: WebSocket energy/get_prefs for configured entities, REST /api/states for unconfigured entity detection, German warning messages for dashboard banner + log, thread-safe design for non-blocking startup, 10-second timeout on WebSocket connection.
  </done>
</task>

</tasks>

<verification>
- `forecaster/` package exists with `__init__.py`, `consumption.py`, `ha_energy.py`
- ConsumptionForecaster can be imported: `from forecaster import ConsumptionForecaster`
- InfluxDB client has both new query methods alongside existing `get_history_hours()`
- Config dataclass has ha_url and ha_token fields
- All files follow existing codebase conventions: snake_case, log() from logging_util, defensive try/except
</verification>

<success_criteria>
- ConsumptionForecaster.get_forecast_24h() returns a 96-element list of Watt values
- ConsumptionForecaster.is_ready returns False before 24h of data
- ConsumptionForecaster.apply_correction() adjusts correction_factor within [0.5, 1.5]
- Model file at /data/ uses atomic write and version checking
- HA entity discovery identifies unconfigured energy entities and logs German warnings
- No new dependencies required (all libraries already in container)
</success_criteria>

<output>
After completion, create `.planning/phases/03-data-foundation/03-01-SUMMARY.md`
</output>

---
phase: 01-state-infrastructure
plan: 02
type: execute
wave: 2
depends_on:
  - 01-01
files_modified:
  - evcc-smartload/rootfs/app/config_validator.py
  - evcc-smartload/rootfs/app/config.py
  - evcc-smartload/rootfs/app/main.py
  - evcc-smartload/rootfs/app/web/server.py
  - evcc-smartload/rootfs/app/web/templates/error.html
autonomous: true
requirements:
  - RELI-04

must_haves:
  truths:
    - "If a user provides an invalid critical configuration value (e.g., missing evcc_url, min_soc > max_soc, efficiency outside (0,1]), the add-on refuses to start optimization and logs a human-readable error explaining which field is wrong and what the valid range is"
    - "Config validation runs before any network connection is attempted, so the add-on fails fast rather than partially initializing"
    - "When critical config errors exist, browsing to port 8099 shows a dedicated error page listing each invalid field with its value, what is wrong, and how to fix it"
    - "Non-critical config issues (e.g., price limits <= 0, missing optional InfluxDB fields) use safe defaults with a warning in the log"
  artifacts:
    - path: "evcc-smartload/rootfs/app/config_validator.py"
      provides: "ConfigValidator class with validate() returning List[ValidationResult]"
      contains: "class ConfigValidator"
      min_lines: 40
    - path: "evcc-smartload/rootfs/app/config_validator.py"
      provides: "ValidationResult dataclass with field, value, severity, message, suggestion"
      contains: "class ValidationResult"
    - path: "evcc-smartload/rootfs/app/web/templates/error.html"
      provides: "Human-readable error page template listing config errors"
      contains: "Konfigurationsfehler"
    - path: "evcc-smartload/rootfs/app/main.py"
      provides: "Validation runs before EvccClient/InfluxDB construction; blocks on critical errors"
      contains: "validator.validate"
  key_links:
    - from: "evcc-smartload/rootfs/app/main.py"
      to: "evcc-smartload/rootfs/app/config_validator.py"
      via: "validator.validate(cfg) call at startup before any I/O"
      pattern: "validator\\.validate\\(cfg\\)"
    - from: "evcc-smartload/rootfs/app/web/server.py"
      to: "evcc-smartload/rootfs/app/web/templates/error.html"
      via: "Error page rendered when config_errors is non-empty"
      pattern: "config_errors"
    - from: "evcc-smartload/rootfs/app/main.py"
      to: "evcc-smartload/rootfs/app/web/server.py"
      via: "Passes config_errors list to WebServer constructor"
      pattern: "config_errors"
---

<objective>
Implement startup config validation with critical/non-critical severity classification and a dedicated error page on the dashboard when configuration is invalid.

Purpose: Currently `load_config()` silently falls back to defaults on any error and applies `setattr` for any key without range-checking. This means a misconfigured add-on can partially initialize, make network connections, and then fail cryptically after a 30-second timeout. After this plan, validation runs before any I/O — critical errors stop the add-on immediately with a clear error page on port 8099, and non-critical issues use safe defaults with logged warnings.

Output: `config_validator.py` (new), `error.html` template (new), modified `main.py` (validation wiring), modified `web/server.py` (error page routing), modified `config.py` (validation hook).
</objective>

<execution_context>
@C:/Users/nicok/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/nicok/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-state-infrastructure/01-RESEARCH.md
@.planning/phases/01-state-infrastructure/01-01-SUMMARY.md

@evcc-smartload/rootfs/app/config.py
@evcc-smartload/rootfs/app/main.py
@evcc-smartload/rootfs/app/web/server.py
@evcc-smartload/rootfs/app/web/templates/dashboard.html
@evcc-smartload/rootfs/app/logging_util.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ConfigValidator with critical/non-critical classification</name>
  <files>evcc-smartload/rootfs/app/config_validator.py</files>
  <action>
Create `config_validator.py` in `evcc-smartload/rootfs/app/` with:

1. **ValidationResult dataclass:**
   ```python
   @dataclass
   class ValidationResult:
       field: str           # Config field name (e.g., "evcc_url")
       value: object        # The actual value found
       severity: str        # "critical" or "warning"
       message: str         # Human-readable German error message including valid range
       suggestion: str = "" # How to fix it
   ```

2. **ConfigValidator class** with a `validate(cfg: Config) -> List[ValidationResult]` method that checks:

   **Critical errors** (add-on cannot function):
   - `evcc_url`: Must be non-empty and start with "http". Message: "evcc_url muss eine gueltige HTTP-URL sein (z.B. http://192.168.1.66:7070)". Suggestion: "Pruefe die IP-Adresse und Port deines evcc-Servers".
   - `battery_min_soc >= battery_max_soc` (if both fields exist on Config): Message: "battery_min_soc ({val}) muss kleiner als battery_max_soc ({val}) sein". Suggestion: "Setze z.B. battery_min_soc=10, battery_max_soc=90".
   - `battery_charge_efficiency` and `battery_discharge_efficiency`: Must be in range (0, 1.0]. Message: "{field} muss zwischen 0 (exklusiv) und 1.0 liegen, ist aber {val}". Suggestion: "Typischer Wert: 0.92".
   - `battery_capacity_kwh`: Must be > 0. Message: "battery_capacity_kwh muss groesser als 0 sein".

   **Non-critical warnings** (safe defaults applied):
   - `battery_max_price_ct` or `ev_max_price_ct` <= 0: Message: "{field} ist {val}ct - wird auf sicheren Default gesetzt". Suggestion: "Typische Werte: battery_max_price_ct=25.0, ev_max_price_ct=30.0".
   - `ev_target_soc` outside [0, 100]: Message: "ev_target_soc ({val}) liegt ausserhalb des gueltigen Bereichs 0-100%".
   - `decision_interval_minutes` < 1 or > 60: Warn and default to 15.
   - InfluxDB fields empty when influxdb_enabled-like usage is detected: Warning only — InfluxDB is optional.

   **Claude's discretion items** (per CONTEXT.md):
   - Classify fields based on "what is impossible without this value" = critical, "what can run with a sensible default" = warning.
   - New v6 config fields that don't exist yet: skip validation (they will be added in later phases).
   - Use `hasattr(cfg, field)` checks before accessing fields that may not exist on the current Config dataclass — the validator must not crash on the current v5 Config shape.

3. **Helper method** `has_critical(results: List[ValidationResult]) -> bool` that returns True if any result has severity "critical".

4. All error messages in German (matching the codebase language pattern from CONTEXT.md). Use plain ASCII in message strings (no special chars that might break in container logs).

5. Import only stdlib + `config.Config`. No external validation libraries (per research: "overkill for ~15 config fields with simple range rules").
  </action>
  <verify>
Run `python -c "from config_validator import ConfigValidator, ValidationResult; v = ConfigValidator(); print('ConfigValidator imported OK')"` from the app directory. Verify `validate()` method exists and returns a list.
  </verify>
  <done>ConfigValidator class exists with validate() returning typed ValidationResult list. Critical fields (evcc_url, SoC bounds, efficiency ranges, capacity) and non-critical fields (price limits, target SoC, interval) are classified. All messages are human-readable German with specific values and fix suggestions.</done>
</task>

<task type="auto">
  <name>Task 2: Wire validation into startup, add error page, and route on config errors</name>
  <files>
    evcc-smartload/rootfs/app/main.py
    evcc-smartload/rootfs/app/web/server.py
    evcc-smartload/rootfs/app/web/templates/error.html
    evcc-smartload/rootfs/app/config.py
  </files>
  <action>
**main.py changes** (builds on Plan 01's StateStore integration):

1. Import `ConfigValidator` from `config_validator`.
2. Immediately after `cfg = load_config()` (and BEFORE creating EvccClient, InfluxDBClient, or any network-connected object), run:
   ```python
   validator = ConfigValidator()
   config_errors = validator.validate(cfg)
   critical = [e for e in config_errors if e.severity == "critical"]
   ```
3. Log ALL errors (critical as "error" level, warnings as "warning" level) using `logging_util.log()`:
   ```python
   for e in config_errors:
       level = "error" if e.severity == "critical" else "warning"
       log(level, f"Config {e.field}: {e.message}")
       if e.suggestion:
           log(level, f"  -> {e.suggestion}")
   ```
4. Create StateStore and start WebServer FIRST (so the error page is reachable even on critical errors):
   ```python
   store = StateStore()
   web = WebServer(cfg, store, config_errors=config_errors)
   web.start()
   ```
5. If critical errors exist, log a final summary and block:
   ```python
   if critical:
       log("error", f"Kritische Config-Fehler ({len(critical)} Fehler) - Add-on startet nicht. Bitte options.json pruefen.")
       log("error", f"Fehlerseite erreichbar unter http://localhost:8099")
       while True:
           time.sleep(60)
   ```
   This ensures the web server stays running to serve the error page, but NO optimization loop, no evcc connections, no InfluxDB writes.

6. For non-critical warnings: apply safe defaults in-place on the cfg object before continuing. For example, if `ev_max_price_ct <= 0`, set `cfg.ev_max_price_ct = 30.0` and log the override.

**web/server.py changes:**

1. Accept `config_errors: List = None` parameter in WebServer.__init__(). Store as `self._config_errors = config_errors or []`.
2. Pass `config_errors` to the server instance so the handler can access it via `self.server._config_errors`.
3. In the `do_GET` handler, BEFORE all normal routing, add a guard:
   ```python
   if self.server._config_errors and any(e.severity == "critical" for e in self.server._config_errors):
       if path == "/" or path == "":
           self._render_error_page()
           return
       elif path == "/status":
           # API callers get JSON error
           self._json({"error": "Add-on nicht gestartet - Konfigurationsfehler",
                        "details": [{"field": e.field, "message": e.message, "severity": e.severity} for e in self.server._config_errors]}, 503)
           return
       elif path.startswith("/static/"):
           pass  # Allow static files (CSS) so error page looks correct
       else:
           self._json({"error": "Add-on nicht gestartet - Konfigurationsfehler"}, 503)
           return
   ```
4. Add `_render_error_page()` method that renders the `error.html` template with `config_errors` context. Use the existing `template_engine.py` to render it, same pattern as `dashboard.html`.

**error.html template** (new file at `evcc-smartload/rootfs/app/web/templates/error.html`):

Create a clean, readable error page in German:
- Title: "SmartLoad - Konfigurationsfehler"
- Red alert banner at top: "Das Add-on konnte nicht gestartet werden"
- Subtitle: "Folgende Konfigurationsfehler wurden gefunden:"
- For each error, display a card/row with:
  - Field name (bold)
  - Current value (monospace)
  - Error message
  - Suggestion (if present, in a lighter/italic style)
  - Severity badge: red "Kritisch" for critical, yellow "Warnung" for warning
- Footer: "Bitte korrigiere die Werte in der Add-on Konfiguration und starte das Add-on neu."
- Use inline CSS (no external stylesheet dependency needed, but link to style.css if it exists for consistency). Keep it simple and readable.
- Include the existing static/style.css link so the page matches the dashboard aesthetic.

**config.py changes** (minimal):

Add a comment at the top of `load_config()` noting that validation is now handled by `ConfigValidator` in `main.py` and that `load_config()` should NOT silently fix invalid values (the validator handles classification and the caller handles remediation). Do NOT remove existing fallback behavior in `load_config()` — it still provides type coercion, but range validation is now the validator's job.

Per user decision (Config-Migration): "Bestehende statische Euro-Limits werden als Fallback behalten". Do NOT remove `ev_max_price_ct` or `battery_max_price_ct` from Config — they stay as fallback values. The validator just warns if they are unreasonable.
  </action>
  <verify>
1. Grep for validation in main.py: `grep "validator.validate" evcc-smartload/rootfs/app/main.py` should match.
2. Verify validation runs BEFORE network objects: in main.py, the `validator.validate(cfg)` call must appear before any `EvccClient(`, `InfluxDBClient(`, or `requests.` calls.
3. Verify error page exists: `ls evcc-smartload/rootfs/app/web/templates/error.html` succeeds.
4. Grep for error routing: `grep "config_errors" evcc-smartload/rootfs/app/web/server.py` should return matches in both __init__ and do_GET.
5. Grep for critical block: `grep "Kritische Config-Fehler" evcc-smartload/rootfs/app/main.py` should match.
6. Verify euro limits preserved: `grep "ev_max_price_ct\|battery_max_price_ct" evcc-smartload/rootfs/app/config.py` still shows these fields.
  </verify>
  <done>
Config validation runs at startup before any network I/O. Critical errors (evcc_url, SoC bounds, efficiency, capacity) stop the optimization loop while keeping the web server alive to show an error page in German on port 8099. Non-critical issues (price limits, optional fields) use safe defaults with warnings. All API endpoints return 503 with error details when config is critically invalid. Euro limit fallback fields are preserved per user decision.
  </done>
</task>

</tasks>

<verification>
1. `config_validator.py` exists with `ConfigValidator` and `ValidationResult` classes
2. `ConfigValidator.validate()` checks critical fields (evcc_url, SoC bounds, efficiency, capacity) and non-critical fields (price limits, target SoC)
3. `main.py` calls `validator.validate(cfg)` BEFORE any `EvccClient`, `InfluxDBClient`, or network object construction
4. `main.py` logs all errors with field names and human-readable messages
5. `main.py` blocks optimization loop on critical errors but keeps web server alive
6. `web/server.py` serves error page at `/` when critical config errors exist
7. `web/server.py` returns 503 JSON on API endpoints when config is invalid
8. `error.html` displays field name, value, message, suggestion, and severity for each error
9. Euro limit config fields (`ev_max_price_ct`, `battery_max_price_ct`) are preserved in `config.py`
10. Non-critical issues get safe defaults applied with warning logs
</verification>

<success_criteria>
- The add-on rejects invalid critical config at startup with clear German error messages in both the container log and the dashboard error page on port 8099
- Validation runs before any network connection is attempted (fail-fast)
- Non-critical config issues degrade gracefully with safe defaults and warnings
- The error page is accessible at the same port 8099 as the normal dashboard
- Existing config fields (including static euro limits) are preserved for backward compatibility
</success_criteria>

<output>
After completion, create `.planning/phases/01-state-infrastructure/01-02-SUMMARY.md`
</output>

---
phase: 01-state-infrastructure
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - evcc-smartload/rootfs/app/state_store.py
  - evcc-smartload/rootfs/app/main.py
  - evcc-smartload/rootfs/app/web/server.py
  - evcc-smartload/rootfs/app/web/templates/dashboard.html
  - evcc-smartload/rootfs/app/web/static/app.js
autonomous: true
requirements:
  - RELI-03

must_haves:
  truths:
    - "Under concurrent load (web request + decision loop + vehicle polling), the dashboard never shows corrupted or partially-updated state"
    - "All state writes from DataCollector go through a single RLock-guarded StateStore; the web server only reads, never writes"
    - "Dashboard receives live state updates via SSE without polling"
  artifacts:
    - path: "evcc-smartload/rootfs/app/state_store.py"
      provides: "RLock-guarded StateStore with snapshot(), update(), and SSE broadcast"
      contains: "class StateStore"
      min_lines: 50
    - path: "evcc-smartload/rootfs/app/main.py"
      provides: "Decision loop writes to StateStore instead of WebServer"
      contains: "store.update"
    - path: "evcc-smartload/rootfs/app/web/server.py"
      provides: "Web handler reads from StateStore.snapshot(); SSE endpoint at /events"
      contains: "snapshot"
  key_links:
    - from: "evcc-smartload/rootfs/app/main.py"
      to: "evcc-smartload/rootfs/app/state_store.py"
      via: "store.update() call in decision loop"
      pattern: "store\\.update\\("
    - from: "evcc-smartload/rootfs/app/web/server.py"
      to: "evcc-smartload/rootfs/app/state_store.py"
      via: "store.snapshot() in every API handler"
      pattern: "snapshot\\(\\)"
    - from: "evcc-smartload/rootfs/app/web/server.py"
      to: "evcc-smartload/rootfs/app/state_store.py"
      via: "SSE /events endpoint reads from client queues filled by StateStore"
      pattern: "/events"
---

<objective>
Implement thread-safe StateStore with RLock guard and SSE push, then migrate the web server to read-only and the decision loop to write through StateStore.

Purpose: Eliminates the two race conditions identified in the codebase — (1) WebServer reads four unguarded instance variables while the decision loop writes them, and (2) VehicleMonitor writes vehicle data without coordinating with DataCollector. After this plan, all shared state flows through a single RLock-guarded store, and the dashboard receives live updates via SSE instead of polling.

Output: `state_store.py` (new), modified `main.py`, modified `web/server.py`, updated dashboard JS for SSE consumption.
</objective>

<execution_context>
@C:/Users/nicok/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/nicok/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-state-infrastructure/01-RESEARCH.md

@evcc-smartload/rootfs/app/state.py
@evcc-smartload/rootfs/app/main.py
@evcc-smartload/rootfs/app/web/server.py
@evcc-smartload/rootfs/app/vehicle_monitor.py
@evcc-smartload/rootfs/app/collector.py
@evcc-smartload/rootfs/app/web/templates/dashboard.html
@evcc-smartload/rootfs/app/web/static/app.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create StateStore with RLock, snapshot, and SSE broadcast</name>
  <files>evcc-smartload/rootfs/app/state_store.py</files>
  <action>
Create `state_store.py` in `evcc-smartload/rootfs/app/` with a `StateStore` class that:

1. **RLock-guarded state fields:** Uses `threading.RLock` (not Lock — re-entrant to prevent deadlock if nested calls occur). Stores: `_state` (Optional[SystemState]), `_lp_action` (Optional[Action]), `_rl_action` (Optional[Action]), `_solar_forecast` (List[Dict]), plus a `_last_update` timestamp (datetime).

2. **`update()` method:** Accepts `state`, `lp_action`, `rl_action`, `solar_forecast` parameters. Acquires lock, updates all four fields plus `_last_update = datetime.now(timezone.utc)`, then broadcasts to SSE clients. Release lock BEFORE broadcasting to avoid holding the RLock during I/O (the broadcast iterates client queues which could be slow).

3. **`snapshot()` method:** Acquires lock, returns a dict with shallow copies (`copy.copy()`) of all four fields plus `_last_update`. Use `copy.copy()` not `dataclasses.asdict()` (asdict is recursive and slower; SystemState fields are primitives + lists so shallow copy is safe — see research doc).

4. **SSE client management:** Maintain `_sse_clients: List[queue.Queue]` and a separate `_sse_lock: threading.Lock` for the client list (NOT the main RLock). Provide `register_sse_client() -> queue.Queue` (creates Queue(maxsize=10), appends under _sse_lock, returns it) and `unregister_sse_client(q)` (removes under _sse_lock). The `_broadcast()` method iterates `list(self._sse_clients)` (copy to avoid mutation during iteration — see Pitfall 3 in research), calls `q.put_nowait(snapshot_dict)` per client, catches `queue.Full` silently (slow client, drop update).

5. **Import only stdlib:** `threading`, `copy`, `queue`, `datetime`, `json`, `typing`. Import `SystemState` and `Action` from `state` module.

Do NOT hold the RLock during SSE broadcast (anti-pattern from research: "Never hold StateStore._lock during I/O").
  </action>
  <verify>
Run `python -c "from state_store import StateStore; s = StateStore(); print('StateStore imported OK')"` from `evcc-smartload/rootfs/app/` directory. Verify the class has `update()`, `snapshot()`, `register_sse_client()`, `unregister_sse_client()` methods.
  </verify>
  <done>StateStore class exists with RLock-guarded update/snapshot and SSE broadcast via queue.Queue fan-out. No external dependencies added.</done>
</task>

<task type="auto">
  <name>Task 2: Migrate main.py and web/server.py to use StateStore; add SSE endpoint and dashboard SSE client</name>
  <files>
    evcc-smartload/rootfs/app/main.py
    evcc-smartload/rootfs/app/web/server.py
    evcc-smartload/rootfs/app/web/templates/dashboard.html
    evcc-smartload/rootfs/app/web/static/app.js
  </files>
  <action>
**main.py changes:**

1. Import `StateStore` from `state_store`.
2. After `load_config()`, create `store = StateStore()`.
3. Pass `store` to `WebServer` constructor (instead of or in addition to current params).
4. In the main decision loop (the `while True` block), after the LP and RL optimizers produce their actions, call `store.update(state=state, lp_action=lp_action, rl_action=rl_action, solar_forecast=solar_forecast)` instead of (or in addition to) `web.update_state(...)`.
5. Remove the direct calls to `web.update_state()` — the web server now reads from `store.snapshot()` only. If `web.update_state()` is still used elsewhere (e.g., for the comparator or decision_log), keep those as separate fields on WebServer but the four main state fields MUST come from StateStore.

**web/server.py changes:**

1. Add `socketserver.ThreadingMixIn` to the HTTPServer class so SSE connections don't block other requests. This is a two-line change: `class ThreadedHTTPServer(socketserver.ThreadingMixIn, HTTPServer): daemon_threads = True` (see research recommendation).
2. Accept `store: StateStore` in WebServer.__init__(). Store as `self._store`.
3. Remove `self._last_state`, `self._last_lp_action`, `self._last_rl_action`, `self._last_solar_forecast` instance variables. Remove the `update_state()` method that wrote to these variables.
4. In `_api_status()` and all other handler methods that read state: replace `self._last_state` etc. with `snap = self._store.snapshot()` at the TOP of the method, then use `snap["state"]`, `snap["lp_action"]`, etc. throughout. This ensures one atomic snapshot per request (see anti-pattern in research: "Unguarded multi-attribute reads").
5. Add SSE endpoint at `/events` in `do_GET`:
   - Set response headers: `Content-Type: text/event-stream`, `Cache-Control: no-cache`, `Connection: keep-alive`, `Access-Control-Allow-Origin: *`.
   - Call `client_q = self.server._store.register_sse_client()`.
   - Enter a loop: `client_q.get(timeout=30)` → write `data: {json}\n\n`; on `queue.Empty` → write `: keepalive\n\n`.
   - On `BrokenPipeError`/`ConnectionResetError`, call `self.server._store.unregister_sse_client(client_q)`.
   - Serialize snapshot data for SSE using `json.dumps()` with a `default=str` fallback for datetime objects.
6. Store a reference to `store` on the server instance so the handler can access it via `self.server._store`.

**dashboard.html changes:**

Add a `<span>` or small indicator near the header showing connection status (e.g., a colored dot — green when SSE connected, grey when disconnected). Add a `<span class="update-age">` next to key data points that shows "vor X Min aktualisiert" (per user decision: dual feedback strategy with timestamp per data point).

**app.js changes:**

1. Add an `EventSource` connection to `/events`.
2. On `message` event: parse JSON, update DOM elements with new values. For each updated value, add a CSS class `highlight` (triggers the brief visual flash per user decision), then remove it after 1.5 seconds via `setTimeout`.
3. On `error`: set connection indicator to grey/disconnected, attempt reconnect (EventSource reconnects automatically, but update the UI indicator).
4. Keep the existing polling as fallback: if SSE fails, the old `/status` polling continues to work. Do NOT remove existing polling logic — SSE is an enhancement.

Per user decision: "Kurzes Highlight (1-2 Sek) bei Wertaenderung UND dauerhafter Timestamp ('vor X Min aktualisiert') pro Datenpunkt". Implement both: CSS transition flash on value change + persistent age label.
  </action>
  <verify>
1. Verify the add-on builds and starts: `docker build -t smartload-test evcc-smartload/` succeeds (or at minimum, `python -c "from web.server import WebServer; from state_store import StateStore"` imports cleanly from app directory).
2. Grep for removed anti-patterns: `grep -r "_last_state" evcc-smartload/rootfs/app/web/server.py` should return zero matches (all replaced by snapshot).
3. Grep for new pattern: `grep -r "snapshot()" evcc-smartload/rootfs/app/web/server.py` should return at least one match per handler method.
4. Grep for SSE endpoint: `grep "/events" evcc-smartload/rootfs/app/web/server.py` should match.
5. Grep for ThreadingMixIn: `grep "ThreadingMixIn" evcc-smartload/rootfs/app/web/server.py` should match.
  </verify>
  <done>
Web server reads exclusively from StateStore.snapshot() (no direct state fields). SSE endpoint at /events pushes state to connected browsers. Dashboard JS consumes SSE with visual highlight on change and persistent timestamps. ThreadingMixIn enables concurrent SSE + regular requests. Old polling remains as fallback.
  </done>
</task>

</tasks>

<verification>
1. `state_store.py` exists with `StateStore` class containing `update()`, `snapshot()`, `register_sse_client()`, `unregister_sse_client()`
2. `web/server.py` no longer contains `_last_state`, `_last_lp_action`, `_last_rl_action`, `_last_solar_forecast` instance variables
3. `web/server.py` uses `self.server._store.snapshot()` in all API handlers
4. `web/server.py` has `/events` SSE endpoint with proper Content-Type header
5. `web/server.py` uses `ThreadedHTTPServer(ThreadingMixIn, HTTPServer)` instead of plain `HTTPServer`
6. `main.py` creates `StateStore()` and passes it to `WebServer`
7. `main.py` calls `store.update()` in the decision loop
8. `app.js` creates `EventSource('/events')` and updates DOM on message
9. Dashboard shows visual highlight on value change and persistent update timestamp
</verification>

<success_criteria>
- StateStore is the single source of truth for shared state between threads
- Web server is strictly read-only (no state writes)
- All state reads in web handlers use a single atomic snapshot() call
- SSE endpoint streams state changes to connected browsers
- Dashboard shows live updates with visual feedback (highlight + timestamp)
- No external dependencies added (all stdlib)
</success_criteria>

<output>
After completion, create `.planning/phases/01-state-infrastructure/01-01-SUMMARY.md`
</output>

---
phase: 08-residual-rl-and-learning
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - evcc-smartload/rootfs/app/seasonal_learner.py
  - evcc-smartload/rootfs/app/forecast_reliability.py
autonomous: true
requirements: [LERN-02, LERN-04]

must_haves:
  truths:
    - "SeasonalLearner accumulates plan errors in a 48-cell lookup table indexed by (season, time_period, is_weekend)"
    - "Each SeasonalLearner cell exposes sample_count so downstream consumers can weight low-confidence cells"
    - "ForecastReliabilityTracker computes per-source (PV, consumption, price) rolling MAE and confidence factors"
    - "PV forecast errors are computed in kW (not mixing W and kW units)"
    - "Both learners persist to JSON and survive container restarts"
  artifacts:
    - path: "evcc-smartload/rootfs/app/seasonal_learner.py"
      provides: "SeasonalLearner with 48-cell lookup, update(), get_correction_factor(), persistence"
      contains: "class SeasonalLearner"
    - path: "evcc-smartload/rootfs/app/forecast_reliability.py"
      provides: "ForecastReliabilityTracker with rolling MAE, confidence factors, persistence"
      contains: "class ForecastReliabilityTracker"
  key_links:
    - from: "evcc-smartload/rootfs/app/seasonal_learner.py"
      to: "/data/smartprice_seasonal_model.json"
      via: "Atomic JSON save/load with version field"
      pattern: "smartprice_seasonal_model"
    - from: "evcc-smartload/rootfs/app/forecast_reliability.py"
      to: "/data/smartprice_forecast_reliability.json"
      via: "Atomic JSON save/load with deque serialization"
      pattern: "smartprice_forecast_reliability"
---

<objective>
Create the SeasonalLearner (48-cell lookup table for plan error patterns) and ForecastReliabilityTracker (per-source rolling MAE with confidence factors) as standalone modules with JSON persistence.

Purpose: LERN-02 requires seasonal pattern adaptation; LERN-04 requires forecast reliability tracking with confidence factors. Both are deployed immediately at Phase 8 start to begin data accumulation.
Output: seasonal_learner.py and forecast_reliability.py as new standalone modules
</objective>

<execution_context>
@C:/Users/nicok/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/nicok/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-residual-rl-and-learning/08-RESEARCH.md
@evcc-smartload/rootfs/app/dynamic_buffer.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create SeasonalLearner module</name>
  <files>evcc-smartload/rootfs/app/seasonal_learner.py</files>
  <action>
Create `seasonal_learner.py` with the `SeasonalLearner` class. Follow the DynamicBufferCalc pattern for persistence and thread safety.

1. **Cell indexing (48 cells total):**
   - `season`: 4 values. Use explicit MONTH_TO_SEASON mapping (NOT naive `(month-1)//3`):
     ```python
     MONTH_TO_SEASON = {12: 0, 1: 0, 2: 0,   # winter (DJF)
                         3: 1, 4: 1, 5: 1,    # spring (MAM)
                         6: 2, 7: 2, 8: 2,    # summer (JJA)
                         9: 3, 10: 3, 11: 3}  # autumn (SON)
     ```
   - `time_period`: 6 values. 0=00-04h, 1=04-08h, 2=08-12h, 3=12-16h, 4=16-20h, 5=20-24h
   - `is_weekend`: 2 values. 0=weekday (Mon-Fri), 1=weekend (Sat-Sun)
   - Cell key: tuple `(season, time_period, is_weekend)` → string key `"s{season}_t{period}_w{weekend}"` for JSON serialization.

2. **Cell data structure:** Each cell stores `{"sum_error": float, "count": int, "mean_error": float}`.
   - `plan_error = actual_cost_eur - plan_cost_eur` (positive = plan was optimistic, actual was more expensive)
   - Document sign convention in class docstring.

3. **Public methods:**
   - `__init__()`: Initialize empty cells dict, threading.Lock, load from disk if file exists.
   - `update(dt: datetime, plan_error_eur: float)`: Record one error. Update sum_error, count, mean_error under lock. Persist every 10 updates (file I/O outside lock, matching DynamicBufferCalc pattern).
   - `get_correction_factor(dt: datetime, min_samples: int = 10) -> Optional[float]`: Return mean_error for current cell if count >= min_samples, else None. Thread-safe.
   - `get_cell(dt: datetime) -> dict`: Return cell dict for current context (always returns dict, may have count=0).
   - `populated_cell_count() -> int`: Count of cells with count > 0.
   - `get_all_cells() -> dict`: Return copy of all cells for dashboard display.
   - `save()`: Atomic write to `/data/smartprice_seasonal_model.json`. Format: `{"version": 1, "cells": {key: cell_dict, ...}}`.
   - `_load()`: Load from file if exists. Version check (currently only v1). Graceful fallback on missing/corrupt file.

4. **Persistence path:** `SEASONAL_MODEL_PATH = "/data/smartprice_seasonal_model.json"`

5. **Thread safety:** `threading.Lock()` for `_cells` dict access. File I/O outside lock (serialize under lock, write after release).

6. **No decay:** Simple running average. No exponential decay for now (research recommendation: keep simple, add decay in Phase 9 if needed).

7. **Minimum sample threshold:** Default `min_samples=10` in get_correction_factor(). Cells with fewer samples return None (caller treats as no correction).
  </action>
  <verify>
    <automated>cd /c/users/nicok/projects/smartload && python -c "
import sys; sys.path.insert(0, 'evcc-smartload/rootfs/app')
from seasonal_learner import SeasonalLearner, MONTH_TO_SEASON
# Verify month-to-season mapping (Pitfall 3)
assert MONTH_TO_SEASON[12] == 0, 'December must be winter (0)'
assert MONTH_TO_SEASON[1] == 0, 'January must be winter (0)'
assert MONTH_TO_SEASON[6] == 2, 'June must be summer (2)'
assert MONTH_TO_SEASON[9] == 3, 'September must be autumn (3)'
# Verify class structure
learner = SeasonalLearner.__new__(SeasonalLearner)
assert hasattr(learner, 'update')
assert hasattr(learner, 'get_correction_factor')
assert hasattr(learner, 'get_cell')
assert hasattr(learner, 'populated_cell_count')
assert hasattr(learner, 'save')
print('PASS: SeasonalLearner structure verified')
"
    </automated>
    <manual>Verify seasonal_learner.py has correct month-to-season mapping and all public methods</manual>
  </verify>
  <done>SeasonalLearner class exists with 48-cell lookup table, correct DJF/MAM/JJA/SON season mapping, update/get_correction_factor methods, atomic JSON persistence, thread safety</done>
</task>

<task type="auto">
  <name>Task 2: Create ForecastReliabilityTracker module</name>
  <files>evcc-smartload/rootfs/app/forecast_reliability.py</files>
  <action>
Create `forecast_reliability.py` with the `ForecastReliabilityTracker` class.

1. **Three sources tracked:** `"pv"`, `"consumption"`, `"price"`. Each has a rolling deque of absolute errors.

2. **Reference scales for normalizing MAE to [0, 1]:**
   ```python
   REFERENCE_SCALE = {
       "pv": 5000.0,          # W — 5 kW is a "large" PV error
       "consumption": 2000.0,  # W — 2 kW is a large consumption error
       "price": 0.10,          # EUR/kWh — 10ct is a large price error
   }
   ```
   Note: PV reference scale is in W but actual errors should be computed in kW (see update method). The reference scale for PV should be `5.0` (kW) to match. **IMPORTANT (Pitfall 4):** All PV comparisons must be in the same unit. Since PVForecaster returns kW and state.pv_power is W, the caller must convert. Document this requirement in update() docstring, but also enforce internally:

   Actually, keep REFERENCE_SCALE in the unit that update() receives. Since the caller will pass already-converted values (both in same unit), the scale must match that unit. Use kW for PV:
   ```python
   REFERENCE_SCALE = {
       "pv": 5.0,             # kW — 5 kW is a "large" PV error (caller converts W->kW)
       "consumption": 2000.0,  # W — 2 kW is a large consumption error (stays in W)
       "price": 0.10,          # EUR/kWh — 10ct is a large price error
   }
   ```

3. **Window size:** `WINDOW_SIZE = 50` cycles (about 12.5 hours at 15-min intervals).

4. **Public methods:**
   - `__init__()`: Initialize `_windows` dict of deques (one per source, maxlen=WINDOW_SIZE), threading.Lock, load from disk.
   - `update(source: str, actual: float, forecast: float)`: Compute `abs(actual - forecast)`, append to source's deque under lock. Validate source is one of the three known sources. Persist every 10 updates.
   - `get_confidence(source: str) -> float`: If fewer than 5 errors recorded, return 1.0 (assume reliable until proven otherwise). Else: `mae = mean(errors)`, `confidence = max(0.0, 1.0 - min(mae / REFERENCE_SCALE[source], 1.0))`. Thread-safe.
   - `get_all_confidences() -> dict`: Returns `{"pv": float, "consumption": float, "price": float}`.
   - `save()`: Atomic write to `/data/smartprice_forecast_reliability.json`. Format: `{"version": 1, "windows": {"pv": [errors], "consumption": [errors], "price": [errors]}}`.
   - `_load()`: Load from file. Graceful fallback on missing/corrupt.

5. **Persistence path:** `RELIABILITY_MODEL_PATH = "/data/smartprice_forecast_reliability.json"`

6. **Thread safety:** `threading.Lock()` for deque access. File I/O outside lock.

7. **Docstring convention:** Document sign convention: `plan_error = actual_cost_eur - plan_cost_eur`. Document unit requirements: "PV values must be in kW (caller converts state.pv_power from W to kW before passing)".
  </action>
  <verify>
    <automated>cd /c/users/nicok/projects/smartload && python -c "
import sys; sys.path.insert(0, 'evcc-smartload/rootfs/app')
from forecast_reliability import ForecastReliabilityTracker, REFERENCE_SCALE, WINDOW_SIZE
assert 'pv' in REFERENCE_SCALE
assert 'consumption' in REFERENCE_SCALE
assert 'price' in REFERENCE_SCALE
assert WINDOW_SIZE == 50
# PV scale should be in kW (Pitfall 4)
assert REFERENCE_SCALE['pv'] <= 10.0, f'PV scale {REFERENCE_SCALE[\"pv\"]} looks like W not kW'
tracker = ForecastReliabilityTracker.__new__(ForecastReliabilityTracker)
assert hasattr(tracker, 'update')
assert hasattr(tracker, 'get_confidence')
assert hasattr(tracker, 'get_all_confidences')
assert hasattr(tracker, 'save')
print('PASS: ForecastReliabilityTracker structure verified')
"
    </automated>
    <manual>Verify forecast_reliability.py uses kW for PV reference scale and has correct window size</manual>
  </verify>
  <done>ForecastReliabilityTracker class exists with per-source rolling MAE (pv in kW, consumption in W, price in EUR/kWh), confidence factor computation, atomic JSON persistence, thread safety, and correct reference scales</done>
</task>

</tasks>

<verification>
1. SeasonalLearner has 48-cell structure with correct DJF/MAM/JJA/SON season mapping
2. ForecastReliabilityTracker has three source windows with correct reference scales
3. PV reference scale is in kW (not W) to match converted forecast values
4. Both modules use atomic JSON write pattern (tmp + os.replace)
5. Both modules use threading.Lock with I/O outside lock
6. Both modules have version fields in JSON for future migration
</verification>

<success_criteria>
- SeasonalLearner correctly maps December to winter (not autumn) per MONTH_TO_SEASON
- ForecastReliabilityTracker confidence returns 1.0 when fewer than 5 samples exist
- Both modules survive missing/corrupt JSON files on load
- Both modules can be imported and instantiated independently (no dependency on main.py wiring)
</success_criteria>

<output>
After completion, create `.planning/phases/08-residual-rl-and-learning/08-02-SUMMARY.md`
</output>

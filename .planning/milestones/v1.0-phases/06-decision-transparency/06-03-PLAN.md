---
phase: 06-decision-transparency
plan: 03
type: execute
wave: 3
depends_on: ["06-01", "06-02"]
files_modified:
  - evcc-smartload/rootfs/app/plan_snapshotter.py
  - evcc-smartload/rootfs/app/main.py
  - evcc-smartload/rootfs/app/web/server.py
  - evcc-smartload/rootfs/app/web/static/app.js
  - evcc-smartload/rootfs/app/web/templates/dashboard.html
autonomous: true
requirements: [TRAN-04]

must_haves:
  truths:
    - "Every decision cycle writes a plan snapshot (slot 0 + total cost) to InfluxDB measurement smartload_plan_snapshot"
    - "GET /history returns JSON with planned vs actual data points for the last 24h (default) or 7 days"
    - "Historie tab shows an overlay chart comparing planned vs actual actions and a detail table with cost-based deviation highlighting"
    - "Cost deviations are shown in EUR with color coding: green = saved vs plan, red = more expensive than plan"
    - "Empty state shown when InfluxDB is not configured or no data available"
  artifacts:
    - path: "evcc-smartload/rootfs/app/plan_snapshotter.py"
      provides: "PlanSnapshotter class with write_snapshot() and query_comparison()"
      contains: "class PlanSnapshotter"
    - path: "evcc-smartload/rootfs/app/main.py"
      provides: "PlanSnapshotter wired into decision loop"
      contains: "plan_snapshotter"
    - path: "evcc-smartload/rootfs/app/web/server.py"
      provides: "GET /history endpoint"
      contains: "/history"
  key_links:
    - from: "evcc-smartload/rootfs/app/main.py"
      to: "evcc-smartload/rootfs/app/plan_snapshotter.py"
      via: "snapshotter.write_snapshot(plan, state) call in decision loop"
      pattern: "write_snapshot"
    - from: "evcc-smartload/rootfs/app/plan_snapshotter.py"
      to: "evcc-smartload/rootfs/app/influxdb_client.py"
      via: "InfluxDBClient.write() and query() calls"
      pattern: "_influx\\.write|_influx\\.query"
    - from: "evcc-smartload/rootfs/app/web/static/app.js"
      to: "GET /history endpoint"
      via: "fetch('/history') in fetchAndRenderHistory()"
      pattern: "fetch.*['\"/]history"
---

<objective>
Implement plan snapshot storage in InfluxDB, the /history API endpoint, and the Historie tab UI with planned-vs-actual overlay chart and cost-deviation detail table.

Purpose: TRAN-04 — users can compare what was planned against what actually happened, with cost-based deviation analysis. This closes the feedback loop: timeline shows the future plan, history shows how well past plans matched reality.
Output: plan_snapshotter.py, updated main.py/server.py/app.js/dashboard.html with history comparison feature
</objective>

<execution_context>
@C:/Users/nicok/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/nicok/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-decision-transparency/06-RESEARCH.md
@.planning/phases/06-decision-transparency/06-01-SUMMARY.md
@.planning/phases/06-decision-transparency/06-02-SUMMARY.md

@evcc-smartload/rootfs/app/main.py
@evcc-smartload/rootfs/app/influxdb_client.py
@evcc-smartload/rootfs/app/web/server.py
@evcc-smartload/rootfs/app/web/static/app.js
@evcc-smartload/rootfs/app/web/templates/dashboard.html
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create PlanSnapshotter, wire into decision loop, add GET /history endpoint</name>
  <files>evcc-smartload/rootfs/app/plan_snapshotter.py, evcc-smartload/rootfs/app/main.py, evcc-smartload/rootfs/app/web/server.py</files>
  <action>
**Create `plan_snapshotter.py` in `rootfs/app/`:**

Class `PlanSnapshotter`:
- Constructor: `__init__(self, influx_client)` — stores reference to InfluxDBClient instance
- **`write_snapshot(self, plan: PlanHorizon, actual_state: dict)`:**
  - Guard: if `plan is None` or `not self._influx._enabled`, return silently
  - Extract slot 0 from plan
  - Write to InfluxDB measurement `smartload_plan_snapshot` with fields:
    - `planned_bat_charge_kw`: `slot0.bat_charge_kw` (float)
    - `planned_bat_discharge_kw`: `slot0.bat_discharge_kw` (float)
    - `planned_ev_charge_kw`: `slot0.ev_charge_kw` (float)
    - `planned_price_ct`: `round(slot0.price_eur_kwh * 100, 2)` (float)
    - `planned_total_cost_eur`: `plan.solver_fun` (float)
    - `actual_bat_power_w`: from actual_state (use existing state key for battery power, e.g., `actual_state.get('battery_power', 0)`)
    - `actual_ev_power_w`: from actual_state (use existing state key for EV power)
    - `actual_price_ct`: from actual_state (use existing state key for current price, multiply by 100 if in EUR)
  - Wrap entire write in try/except to never crash the decision loop (log warning on failure)
  - Use existing `self._influx.write(measurement=..., fields=...)` pattern from influxdb_client.py

- **`query_comparison(self, hours: int = 24) -> list`:**
  - Guard: if `not self._influx._enabled`, return `[]`
  - Query InfluxDB: `SELECT * FROM smartload_plan_snapshot WHERE time > now() - {hours}h ORDER BY time ASC`
  - Parse response into list of dicts: `[{time, planned_bat_charge_kw, planned_price_ct, actual_bat_power_w, actual_price_ct, ...}]`
  - Convert `actual_bat_power_w` to kW (÷1000) for consistent units
  - Compute cost deviation per row: `cost_delta_eur = (actual_price_ct - planned_price_ct) / 100 * planned_bat_charge_kw * 0.25` (approximate 15-min cost diff)
  - Return list with all fields + computed `cost_delta_eur`
  - Wrap in try/except, return `[]` on failure

**main.py changes:**

1. Import: `from plan_snapshotter import PlanSnapshotter`
2. After InfluxDB client initialization, create: `plan_snapshotter = PlanSnapshotter(influx_client)`
3. In the decision loop, AFTER `store.update_plan(plan)` is called (after successful LP solve):
   - Build `actual_state` dict from current state: `{"battery_power": state.battery_power, "ev_power": state.ev_power, "current_price": state.current_price}` (use whatever field names exist in the state object — check `state.py` for exact names)
   - Call `plan_snapshotter.write_snapshot(plan, actual_state)` wrapped in try/except (same pattern as `buffer_calc.step()`)
4. Wire snapshotter to WebServer: `web.plan_snapshotter = plan_snapshotter` (late assignment, same pattern as buffer_calc)

**server.py changes:**

1. Add `plan_snapshotter = None` to `WebServer.__init__()` (like buffer_calc pattern)
2. Add GET `/history` route in `do_GET`:
   ```python
   elif path == "/history":
       hours = 24  # default
       if "?" in self.path:
           qs = parse_qs(urlparse(self.path).query)
           hours = int(qs.get("hours", ["24"])[0])
           if hours not in (24, 168):  # 24h or 7d
               hours = 24
       if srv.plan_snapshotter is None:
           self._json({"available": False, "rows": [], "reason": "snapshotter not initialized"})
       else:
           rows = srv.plan_snapshotter.query_comparison(hours)
           self._json({"available": bool(rows), "hours": hours, "rows": rows})
   ```
3. Import `urlparse` and `parse_qs` from `urllib.parse` if not already imported
  </action>
  <verify>
    <automated>cd C:/users/nicok/projects/smartload &amp;&amp; python -c "import sys; sys.path.insert(0, 'evcc-smartload/rootfs/app'); from plan_snapshotter import PlanSnapshotter; print('Import OK')" &amp;&amp; grep -c "plan_snapshotter" evcc-smartload/rootfs/app/main.py &amp;&amp; grep -c "/history" evcc-smartload/rootfs/app/web/server.py</automated>
    <manual>Verify write_snapshot writes to InfluxDB, query_comparison returns list of dicts</manual>
  </verify>
  <done>PlanSnapshotter writes slot-0 snapshot each cycle to InfluxDB; /history endpoint returns planned-vs-actual data for 24h/7d; snapshotter wired into main.py decision loop</done>
</task>

<task type="auto">
  <name>Task 2: Implement Historie tab UI with overlay chart and cost-deviation table</name>
  <files>evcc-smartload/rootfs/app/web/static/app.js, evcc-smartload/rootfs/app/web/templates/dashboard.html</files>
  <action>
**app.js additions:**

1. **`fetchAndRenderHistory()`** (replace stub from Plan 02):
   - `fetch('/history')` → parse JSON
   - If `!data.available || !data.rows.length`: show `$('historyNoData')`, hide `$('historyContent')`
   - Otherwise: hide `$('historyNoData')`, show `$('historyContent')`
   - Call `renderHistoryChart(data.rows)` and `renderHistoryTable(data.rows)`
   - Add 24h/7d toggle state: `window._historyHours = 24`

2. **`renderHistoryChart(rows)`** — SVG overlay chart (viewBox="0 0 960 200"):
   - Two line series plotted over time:
     - **Planned battery power** (dashed green line): `planned_bat_charge_kw` values, positive = charge, negative = discharge
     - **Actual battery power** (solid blue line): `actual_bat_power_w / 1000` (convert W to kW)
   - X-axis: time labels from `row.time`, show every 2-3 hours
   - Y-axis: kW scale
   - EV charge overlay: planned (dashed blue) vs actual (solid cyan) if data includes EV values
   - Area between planned and actual lines: light red fill where actual > planned (cost more), light green fill where actual < planned (cost less) — simple visualization of deviation

3. **`renderHistoryTable(rows)`** — HTML table:
   - Columns: `Zeit | Geplant (kW) | Tatsächlich (kW) | Preis (ct) | Abweichung (EUR)`
   - For each row:
     - `Zeit`: format `row.time` as `HH:MM` (or `DD.MM HH:MM` if 7d view)
     - `Geplant`: `row.planned_bat_charge_kw` (positive) or `-row.planned_bat_discharge_kw` (negative)
     - `Tatsächlich`: `row.actual_bat_power_w / 1000` (kW)
     - `Preis`: `row.actual_price_ct` (ct)
     - `Abweichung`: `row.cost_delta_eur` formatted with sign, colored green (negative = saved) or red (positive = more expensive)
   - Table styling: reuse existing `.buffer-log-table` CSS pattern (zebra rows, compact)
   - Limit display to most recent 96 rows (24h of 15-min slots) — show "Alle anzeigen" link if more
   - Cost summary at bottom: `"Gesamtabweichung: {sum} EUR"` — green if negative (saved), red if positive

4. **`toggleHistoryRange(hours)`:**
   - Set `window._historyHours = hours`
   - Re-fetch with `fetch('/history?hours=' + hours)` and re-render
   - Update toggle button active state

**dashboard.html changes:**

Update the `#tab-history` panel content (from Plan 01's skeleton):
```html
<div id="tab-history" class="tab-panel" style="display:none;">
    <div class="card">
        <div style="display:flex;justify-content:space-between;align-items:center;">
            <h2>Plan vs. Realität</h2>
            <div>
                <button class="btn-sm history-range active" onclick="toggleHistoryRange(24)">24h</button>
                <button class="btn-sm history-range" onclick="toggleHistoryRange(168)">7 Tage</button>
            </div>
        </div>
        <div id="historyChartWrap"></div>
    </div>
    <div class="card">
        <h2>Detailvergleich</h2>
        <div id="historyTableWrap"></div>
        <div id="historySummary" style="margin-top:8px;font-weight:bold;"></div>
    </div>
    <div id="historyNoData" style="display:none;" class="card">
        <p>Keine historischen Daten verfügbar — InfluxDB nicht konfiguriert oder noch keine Plan-Zyklen aufgezeichnet.</p>
    </div>
    <div id="historyContent"></div>
</div>
```

Note: `historyContent` div is for dynamic content not in the fixed cards. Alternatively, put chart in `historyChartWrap` and table in `historyTableWrap` directly. Adjust the structure so the fixed card headers remain and JS only updates the inner chart/table content.

Use `var` declarations for ES5 compatibility. Follow existing SVG patterns (string concatenation, no template literals).
  </action>
  <verify>
    <automated>cd C:/users/nicok/projects/smartload &amp;&amp; grep -c "fetchAndRenderHistory" evcc-smartload/rootfs/app/web/static/app.js &amp;&amp; grep -c "renderHistoryChart" evcc-smartload/rootfs/app/web/static/app.js &amp;&amp; grep -c "renderHistoryTable" evcc-smartload/rootfs/app/web/static/app.js &amp;&amp; grep -c "historyChartWrap" evcc-smartload/rootfs/app/web/templates/dashboard.html</automated>
    <manual>Verify Historie tab shows overlay chart and cost-deviation table with green/red coloring</manual>
  </verify>
  <done>Historie tab shows overlay chart comparing planned vs actual with deviation shading; detail table shows per-row cost deviation in EUR with green/red coloring; 24h/7d toggle works; summary shows total cost deviation; empty state handled gracefully</done>
</task>

</tasks>

<verification>
1. `PlanSnapshotter.write_snapshot()` called each decision cycle after LP solve — never crashes on failure
2. `GET /history` returns planned-vs-actual rows with cost deviation for 24h (default) and 7d
3. Historie tab shows overlay chart with planned (dashed) vs actual (solid) lines
4. Detail table shows per-slot comparison with cost deviation in EUR (green=saved, red=expensive)
5. 24h/7d toggle re-fetches and re-renders
6. Empty state shows helpful message when InfluxDB unavailable or no data
7. No impact on decision loop performance (snapshot write is fire-and-forget with try/except)
</verification>

<success_criteria>
- Plan snapshots accumulate in InfluxDB every 15-min cycle
- /history endpoint serves comparison data with cost deviations
- Historie tab visualizes planned-vs-actual with cost-based analysis
- Cost deviations use EUR amounts with green/red color coding
- System degrades gracefully when InfluxDB is unavailable
</success_criteria>

<output>
After completion, create `.planning/phases/06-decision-transparency/06-03-SUMMARY.md`
</output>

---
phase: 07-driver-interaction
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - evcc-smartload/rootfs/app/override_manager.py
  - evcc-smartload/rootfs/app/main.py
  - evcc-smartload/rootfs/app/web/server.py
  - evcc-smartload/rootfs/app/notification.py
  - evcc-smartload/rootfs/app/web/static/app.js
  - evcc-smartload/rootfs/app/web/templates/dashboard.html
autonomous: true
requirements: [DRIV-01]

must_haves:
  truths:
    - "Dashboard Boost Charge button on vehicle card triggers immediate charging for that vehicle"
    - "Telegram /boost command and inline button trigger immediate charging"
    - "Override expires after 90 minutes and planner resumes control automatically"
    - "Cancel override works from both dashboard button and Telegram /stop command"
    - "Boost Charge during quiet hours is blocked with German notification message"
    - "Active override appears as marker in plan timeline Gantt chart"
  artifacts:
    - path: "evcc-smartload/rootfs/app/override_manager.py"
      provides: "Thread-safe OverrideManager with activate/cancel/expiry/status"
      contains: "class OverrideManager"
    - path: "evcc-smartload/rootfs/app/web/server.py"
      provides: "POST /override/boost and POST /override/cancel endpoints"
      contains: "_api_override_boost"
    - path: "evcc-smartload/rootfs/app/notification.py"
      provides: "Telegram /boost and /stop command handlers"
      contains: "boost_"
  key_links:
    - from: "evcc-smartload/rootfs/app/web/static/app.js"
      to: "/override/boost"
      via: "fetch POST from Boost button click handler"
      pattern: "override/boost"
    - from: "evcc-smartload/rootfs/app/main.py"
      to: "override_manager.get_status()"
      via: "main loop checks override before applying LP plan"
      pattern: "override_manager"
    - from: "evcc-smartload/rootfs/app/override_manager.py"
      to: "evcc_client.set_loadpoint_mode"
      via: "activate() sets evcc to 'now' mode"
      pattern: "set_loadpoint_mode.*now"
---

<objective>
Implement the Boost Charge override system: a thread-safe OverrideManager that lets drivers trigger immediate charging from the dashboard or Telegram, with 90-minute auto-expiry, quiet-hours guard, and cancel support.

Purpose: Drivers need a way to bypass the LP planner when they need their car charged NOW, without understanding the planner's optimization logic.
Output: Working override system accessible from dashboard vehicle cards and Telegram, with plan timeline marker.
</objective>

<execution_context>
@C:/Users/nicok/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/nicok/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-driver-interaction/07-RESEARCH.md
@.planning/phases/04-predictive-planner/04-02-SUMMARY.md
@.planning/phases/06-decision-transparency/06-02-SUMMARY.md

# Key source files
@evcc-smartload/rootfs/app/main.py
@evcc-smartload/rootfs/app/web/server.py
@evcc-smartload/rootfs/app/notification.py
@evcc-smartload/rootfs/app/charge_sequencer.py
@evcc-smartload/rootfs/app/evcc_client.py
@evcc-smartload/rootfs/app/web/static/app.js
@evcc-smartload/rootfs/app/web/templates/dashboard.html
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create OverrideManager class and wire into main loop and API</name>
  <files>
    evcc-smartload/rootfs/app/override_manager.py
    evcc-smartload/rootfs/app/main.py
    evcc-smartload/rootfs/app/web/server.py
  </files>
  <action>
Create `override_manager.py` with the `OverrideManager` class:

1. **ActiveOverride dataclass**: `vehicle_name: str`, `activated_at: datetime`, `expires_at: datetime`, `activated_by: str` ("dashboard" | "telegram").

2. **OverrideManager class** with constructor `__init__(self, cfg, evcc, notifier=None)`:
   - `self._lock = threading.Lock()`, `self._active: Optional[ActiveOverride] = None`, `self._expiry_timer: Optional[threading.Timer] = None`
   - `OVERRIDE_DURATION_MINUTES = 90`

3. **activate(vehicle_name, source, chat_id=None) -> dict**:
   - Check quiet hours first using `self._is_quiet(now)` (read `cfg.quiet_hours_start` and `cfg.quiet_hours_end`, compare with `datetime.now().hour` — local time, matching existing ChargeSequencer._is_quiet() pattern). If quiet: return `{"ok": False, "quiet_hours_blocked": True, "message": "Leise-Stunden aktiv, Laden startet um {HH:MM}"}` where HH:MM is quiet_hours_end. If chat_id and notifier, also send Telegram message.
   - Under lock: cancel existing timer if any. Create ActiveOverride. Start `threading.Timer(OVERRIDE_DURATION_MINUTES * 60, self._on_expiry)` with `daemon=True`.
   - Call `self.evcc.set_loadpoint_mode(1, "now")` to immediately start charging.
   - Return `{"ok": True, "vehicle": vehicle_name, "expires_at": expires.isoformat(), "remaining_minutes": OVERRIDE_DURATION_MINUTES}`.
   - IMPORTANT: Last-activated-wins strategy. If a Boost is already active for a different vehicle, the new one replaces it. Log the replacement.

4. **cancel() -> dict**: Under lock, clear _active and cancel timer. Return `{"ok": True, "cancelled": vehicle_name}` or `{"ok": False, "message": "Kein aktiver Override"}` if none active. Do NOT call evcc here — the main loop will detect "override cleared" and restore LP-controlled mode on next cycle.

5. **_on_expiry()**: Under lock, clear _active and _expiry_timer. Log expiry. If `self.notifier`, send Telegram message: `"Boost Charge für {vehicle} abgelaufen — Planer übernimmt wieder."` via `self.notifier.bot.send_message()` to all configured chat IDs (iterate `self.notifier.driver_manager.get_all_drivers()` for chat_ids).

6. **get_status() -> dict**: Under lock, return `{"active": False}` or `{"active": True, "vehicle": ..., "expires_at": ..., "remaining_minutes": ..., "activated_by": ...}`.

7. **_is_quiet(now) -> bool**: Check if current local hour falls in quiet hours range (handle overnight wrap: if start > end, quiet when hour >= start OR hour < end). Use `hasattr(self.cfg, 'quiet_hours_start')` guard — if config doesn't have quiet hours, return False.

Wire into **main.py**:
- Import OverrideManager. Initialize after evcc_client and before the main loop: `override_manager = OverrideManager(cfg, evcc, notifier)` (with try/except, None fallback).
- Inject into web server: `srv.override_manager = override_manager` (same late-assignment pattern as `srv.buffer_calc`, `srv.sequencer`).
- In the main decision loop, BEFORE applying LP plan: check `override_manager.get_status()["active"]`. If active: skip LP plan application for EV (keep evcc in "now" mode). If NOT active but evcc was previously in override mode: ensure LP-controlled mode is restored (the normal LP plan application handles this — no extra code needed since `_action_from_plan()` already sets the correct evcc mode).
- Pass override_manager to notifier if available: `notifier.override_manager = override_manager` (for Telegram command handling in Plan 01 Task 2).

Wire into **web/server.py**:
- Add `self.override_manager = None` in `__init__`.
- Add POST `/override/boost` endpoint (`_api_override_boost`): Parse JSON body `{"vehicle": "KIA EV9"}`. Call `self.override_manager.activate(vehicle, "dashboard")`. Return JSON result.
- Add POST `/override/cancel` endpoint (`_api_override_cancel`): Call `self.override_manager.cancel()`. Return JSON result.
- Add GET `/override/status` endpoint (`_api_override_status`): Return `self.override_manager.get_status()` as JSON.
- Guard all three endpoints: if `self.override_manager is None`, return `{"error": "Override nicht verfügbar"}` with 503 status.
  </action>
  <verify>
    <automated>cd evcc-smartload && python -c "
import sys; sys.path.insert(0, 'rootfs/app')
from override_manager import OverrideManager, ActiveOverride
om = OverrideManager.__new__(OverrideManager)
print('OverrideManager class imported OK')
print('Methods:', [m for m in dir(om) if not m.startswith('__')])
assert hasattr(om, 'activate'), 'Missing activate'
assert hasattr(om, 'cancel'), 'Missing cancel'
assert hasattr(om, 'get_status'), 'Missing get_status'
print('ALL CHECKS PASSED')
"</automated>
    <manual>Review override_manager.py for thread safety (all _active access under _lock), quiet-hours guard, 90-min timer.</manual>
  </verify>
  <done>OverrideManager class exists with activate/cancel/expiry/status methods. Main loop checks override status before LP plan. Web server exposes POST /override/boost, POST /override/cancel, GET /override/status endpoints.</done>
</task>

<task type="auto">
  <name>Task 2: Dashboard Boost button and Telegram /boost command</name>
  <files>
    evcc-smartload/rootfs/app/web/static/app.js
    evcc-smartload/rootfs/app/web/templates/dashboard.html
    evcc-smartload/rootfs/app/notification.py
  </files>
  <action>
**Dashboard (app.js + dashboard.html):**

In `app.js`, find the vehicle card rendering function (likely `renderDevice()` or `renderSequencer()` — check existing code). For each vehicle card on the Status tab, add a Boost Charge button:

1. Add a "Boost Charge" button to each vehicle card. The button should call a new `activateBoost(vehicleName)` function.
2. Implement `activateBoost(vehicleName)`:
   - `fetch('/override/boost', {method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({vehicle: vehicleName})})`
   - On success (`ok: true`): Show confirmation inline on the card (e.g., update button text to "Boost aktiv — {remaining_minutes} Min" with a different color/style). Start a 60-second polling interval to update remaining time from GET /override/status.
   - On quiet-hours block (`quiet_hours_blocked: true`): Show the message from the response on the card.
   - On error: Show error message inline.
3. Add a "Override stoppen" (cancel) button that appears ONLY when an override is active for that vehicle. Calls `cancelBoost()`:
   - `fetch('/override/cancel', {method:'POST'})` — on success, revert UI to normal state.
4. Poll GET /override/status in the existing SSE update handler or in `updateUI()` to keep override state current. If override is active, show the remaining time and the active indicator on the relevant vehicle card.

In `dashboard.html`, add CSS for the Boost button styling (`.boost-btn`, `.boost-active`, `.boost-blocked` classes). Keep consistent with existing dashboard styling patterns.

**Gantt chart override marker:**

In `renderPlanGantt()` (already in app.js from Phase 6 Plan 02), check `window._overrideStatus` (populated from SSE or /override/status). If an override is active, draw a horizontal banner/highlight across the current time slot in the Gantt chart with text "Boost Charge aktiv" in a distinct color (e.g., red/orange stripe). This is at Claude's discretion per CONTEXT.md — a banner across the top of the current slot is the simplest approach.

**Telegram (notification.py):**

1. Register new callback prefix `"boost_"` in NotificationManager `__init__`:
   `bot.register_callback("boost_", self._handle_boost_callback)`
2. Register `/boost` command handler. In TelegramBot's `_handle_update()`, detect messages starting with `/boost` and route to NotificationManager. The simplest approach: register a text handler that checks for `/boost` prefix — or if `_handle_text_message` already exists, extend it to check for `/boost` at the top.
3. Implement `_handle_boost_callback(chat_id, data)`: Parse vehicle name from callback data (e.g., `"boost_KIA_EV9"` → `"KIA EV9"`). Call `self.override_manager.activate(vehicle_name, "telegram", chat_id)`. Reply with result message.
4. Implement `/boost [Fahrzeug]` text command handler: Parse vehicle name from message text. If no vehicle specified and only one vehicle exists, use that one. Call `self.override_manager.activate(vehicle, "telegram", chat_id)`. Reply with German confirmation: `"Boost Charge für {vehicle} aktiviert! Läuft {OVERRIDE_DURATION_MINUTES} Minuten."` or the quiet-hours rejection message.
5. Implement `/stop` text command handler: Call `self.override_manager.cancel()`. Reply: `"Override gestoppt — Planer übernimmt."` or `"Kein aktiver Override."` if none active.
6. In existing charge status notifications (where inline buttons are sent), add a "Boost Charge" inline button alongside existing buttons: `{"text": "Jetzt laden!", "callback_data": "boost_{vehicle_name}"}`.

IMPORTANT: Access override_manager via `self.override_manager` (injected by main.py as late attribute).
  </action>
  <verify>
    <automated>cd evcc-smartload && grep -c "activateBoost\|override/boost\|boost_btn\|boost-btn" rootfs/app/web/static/app.js rootfs/app/web/templates/dashboard.html && grep -c "boost_\|_handle_boost\|/stop\|/boost" rootfs/app/notification.py && echo "ALL PATTERNS FOUND"</automated>
    <manual>Check vehicle card has Boost button, Telegram handlers parse /boost and /stop commands, Gantt chart override marker logic exists.</manual>
  </verify>
  <done>Dashboard shows Boost Charge button on each vehicle card. Telegram responds to /boost and /stop commands. Active override shows remaining time on vehicle card and marker in Gantt chart. Charge notifications include inline Boost button.</done>
</task>

</tasks>

<verification>
1. `override_manager.py` exists with OverrideManager class containing activate(), cancel(), get_status(), _on_expiry() methods
2. `main.py` imports and initializes OverrideManager, checks override status in decision loop
3. `web/server.py` has POST /override/boost, POST /override/cancel, GET /override/status endpoints
4. `app.js` has activateBoost(), cancelBoost() functions and override status polling
5. `notification.py` handles /boost command, /stop command, and boost_ callback prefix
6. Quiet hours guard blocks Boost with German message
7. 90-minute expiry timer is daemon thread with auto-notification on expiry
</verification>

<success_criteria>
- POST /override/boost with vehicle name activates override and returns JSON with expires_at
- POST /override/cancel stops override and returns confirmation
- GET /override/status returns current override state
- Dashboard vehicle card shows Boost Charge button; active override shows remaining time
- Telegram /boost [vehicle] and /stop commands work with German responses
- Quiet hours block Boost Charge with informative German message
- Override auto-expires after 90 minutes with Telegram notification
- Gantt chart shows override marker when active
</success_criteria>

<output>
After completion, create `.planning/phases/07-driver-interaction/07-01-SUMMARY.md`
</output>

---
phase: 04-predictive-planner
plan: 02
type: execute
wave: 2
depends_on: [04-01]
files_modified:
  - evcc-smartload/rootfs/app/state_store.py
  - evcc-smartload/rootfs/app/main.py
autonomous: true
requirements: [PLAN-01, PLAN-02]

must_haves:
  truths:
    - "Every 15-min decision cycle, HorizonPlanner.plan() is called with current state, tariffs, consumption_96, pv_96, and departure times"
    - "When LP plan succeeds, the controller receives an Action derived from the plan's slot-0 decision (not from static price thresholds)"
    - "When LP plan fails or returns None, HolisticOptimizer.optimize() is used as fallback (no crash, no downtime)"
    - "StateStore.update_plan() stores the latest PlanHorizon accessible via get_plan()"
    - "Static ev_max_price_ct and battery_max_price_ct are no longer used to gate decisions in the main loop when LP succeeds"
    - "Per-EV departure time from config (ev_charge_deadline_hour) is passed to the planner"
  artifacts:
    - path: "evcc-smartload/rootfs/app/state_store.py"
      provides: "update_plan() and get_plan() methods for PlanHorizon storage"
      contains: "def update_plan"
    - path: "evcc-smartload/rootfs/app/main.py"
      provides: "HorizonPlanner initialization, plan() call in decision loop, fallback chain, _action_from_plan(), _get_departure_times()"
      contains: "horizon_planner"
  key_links:
    - from: "evcc-smartload/rootfs/app/main.py"
      to: "evcc-smartload/rootfs/app/optimizer/planner.py"
      via: "horizon_planner.plan() call in decision loop"
      pattern: "horizon_planner\\.plan\\("
    - from: "evcc-smartload/rootfs/app/main.py"
      to: "evcc-smartload/rootfs/app/state_store.py"
      via: "store.update_plan(plan) after successful LP solve"
      pattern: "store\\.update_plan\\("
    - from: "evcc-smartload/rootfs/app/main.py"
      to: "evcc-smartload/rootfs/app/optimizer/holistic.py"
      via: "fallback: optimizer.optimize() when plan is None"
      pattern: "optimizer\\.optimize\\("
---

<objective>
Wire HorizonPlanner into the main decision loop, replacing static price limits with LP-derived decisions, and extend StateStore for plan storage.

Purpose: This plan connects the LP engine (from 04-01) to the production system. The main loop calls the planner every 15-min cycle, derives controller actions from the LP output, and falls back to HolisticOptimizer when the LP fails. Static price thresholds (ev_max_price_ct, battery_max_price_ct) are no longer used as decision gates — the LP determines optimal charge windows.

Output: A fully wired main.py that prefers LP plan over static thresholds, StateStore with plan storage, and departure time resolution from config.
</objective>

<execution_context>
@C:/Users/nicok/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/nicok/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-predictive-planner/04-RESEARCH.md
@.planning/phases/04-predictive-planner/04-01-SUMMARY.md

# Key source files:
@evcc-smartload/rootfs/app/main.py
@evcc-smartload/rootfs/app/state_store.py
@evcc-smartload/rootfs/app/state.py
@evcc-smartload/rootfs/app/optimizer/holistic.py
@evcc-smartload/rootfs/app/config.py
@evcc-smartload/rootfs/app/controller.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend StateStore with plan storage and add helper functions</name>
  <files>evcc-smartload/rootfs/app/state_store.py</files>
  <action>
**StateStore extensions** (follow existing RLock pattern from Phase 1):

1. Add `_plan: Optional[PlanHorizon] = None` field to `__init__()`.

2. Add `update_plan(self, plan: PlanHorizon) -> None`:
   - Acquire `self._lock`, set `self._plan = plan`, release lock.
   - Do NOT broadcast SSE here — plan data will be included in the next regular `update()` broadcast.
   - Follow exact same pattern as existing field updates.

3. Add `get_plan(self) -> Optional[PlanHorizon]`:
   - Acquire `self._lock`, return `self._plan`.
   - PlanHorizon is immutable after construction (dataclass), safe to return reference.

4. Extend `_snapshot_unlocked()` (or equivalent snapshot method) to include plan summary data:
   - If `self._plan` is not None, add to snapshot:
     - `plan_computed_at`: ISO timestamp
     - `plan_solver_status`: int
     - `plan_cost_eur`: solver_fun value
     - `plan_slots_count`: number of slots
   - This enables the dashboard to show plan status without full PlanHorizon serialization.

5. Extend `_snapshot_to_json_dict()` (the SSE payload builder) to include a `plan_summary` key:
   - `plan_summary: { computed_at, status, cost_eur, current_action: {bat_charge, bat_discharge, ev_charge} }`
   - Keep it lightweight — Phase 6 will add the full slot timeline.

6. Import `PlanHorizon` from `state` at the top of the file.
  </action>
  <verify>
1. `python -c "from state_store import StateStore"` succeeds
2. StateStore has `update_plan()` and `get_plan()` methods
3. `_plan` field is guarded by existing `_lock` (RLock)
4. Snapshot includes plan summary fields when plan is not None
  </verify>
  <done>
- StateStore.update_plan() stores PlanHorizon under RLock
- StateStore.get_plan() returns Optional[PlanHorizon] under RLock
- SSE payload includes plan_summary section when plan exists
- No SSE broadcast in update_plan() (included in next regular update())
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire HorizonPlanner into main.py decision loop with fallback chain</name>
  <files>evcc-smartload/rootfs/app/main.py</files>
  <action>
**Main loop integration** (follow Research Pattern 4 exactly):

1. **Import HorizonPlanner:**
   ```python
   from optimizer.planner import HorizonPlanner
   from state import PlanHorizon, Action
   ```

2. **Initialize HorizonPlanner** in the startup section (after Config and before the main loop):
   ```python
   horizon_planner = None
   try:
       horizon_planner = HorizonPlanner(cfg)
       log("info", "HorizonPlanner: initialized (scipy/HiGHS LP solver)")
   except ImportError as e:
       log("warning", f"HorizonPlanner: scipy not available ({e}), using HolisticOptimizer only")
   except Exception as e:
       log("warning", f"HorizonPlanner: init failed ({e}), using HolisticOptimizer only")
   ```
   This graceful fallback ensures the system works even if scipy is not installed.

3. **Add `_get_departure_times(cfg)` helper** (module-level function in main.py):
   ```python
   def _get_departure_times(cfg) -> Dict[str, datetime]:
       """Return departure datetime per EV name for LP formulation.
       Phase 4: uses cfg.ev_charge_deadline_hour as the single deadline.
       Phase 7 will extend with per-driver Telegram input."""
       now = datetime.now(timezone.utc)
       deadline_hour = getattr(cfg, 'ev_charge_deadline_hour', 6)
       local_deadline = now.replace(hour=deadline_hour, minute=0, second=0, microsecond=0)
       if local_deadline <= now:
           local_deadline += timedelta(days=1)
       return {"_default": local_deadline}
   ```

4. **Add `_action_from_plan(plan, state)` helper** (module-level function in main.py):
   Follow Research code example exactly. Convert PlanHorizon slot-0 to an Action object:
   - If `slot0.bat_charge_kw > 0.1`: battery_action=1 (charge), battery_limit_eur=slot0.price_eur_kwh
   - If `slot0.bat_discharge_kw > 0.1`: battery_action=6 (discharge), battery_limit_eur=None
   - Else: battery_action=0 (hold), battery_limit_eur=None
   - If `slot0.ev_charge_kw > 0.1 and state.ev_connected`: ev_action=1 (charge), ev_limit_eur=slot0.price_eur_kwh
   - Else: ev_action=0, ev_limit_eur=None
   - Return Action with these fields.

5. **Replace decision logic in main loop** — find the section where `lp_action = optimizer.optimize(state, tariffs)` is called. Replace with the fallback chain:
   ```python
   # --- Phase 4: Predictive Planner (LP-based) ---
   plan = None
   if horizon_planner is not None and consumption_96 is not None and pv_96 is not None:
       plan = horizon_planner.plan(
           state=state,
           tariffs=tariffs,
           consumption_96=consumption_96,
           pv_96=pv_96,
           ev_departure_times=_get_departure_times(cfg),
       )

   if plan is not None:
       lp_action = _action_from_plan(plan, state)
       store.update_plan(plan)
   else:
       # Fallback: holistic optimizer (unchanged from Phase 3)
       lp_action = optimizer.optimize(state, tariffs)
   ```
   **CRITICAL:** Keep the existing `optimizer.optimize(state, tariffs)` call as the fallback. Do NOT remove the HolisticOptimizer. It is the safety net.

6. **Access consumption_96 and pv_96 from StateStore** — these are already in the store from Phase 3 (03-03 wired them in). Read them from the store snapshot or from the forecasters directly. Look at how consumption_96 and pv_96 are already used in the decision loop (they were wired by 03-03-PLAN.md). Use the same variables.

7. **Do NOT modify the RL shadow decision path** — the `rl_action = rl_agent.select_action(state, explore=True)` and per-device mode selection code remains unchanged. The LP planner replaces the HolisticOptimizer path, not the RL path.

8. **Log the decision source:**
   ```python
   if plan is not None:
       log("info", f"Decision: LP plan (cost={plan.solver_fun:.4f} EUR), "
                    f"bat={'charge' if plan.current_bat_charge else 'discharge' if plan.current_bat_discharge else 'hold'}, "
                    f"ev={'charge' if plan.current_ev_charge else 'off'}")
   else:
       log("info", "Decision: HolisticOptimizer fallback")
   ```
  </action>
  <verify>
1. main.py imports HorizonPlanner and initializes it with try/except
2. `_get_departure_times()` function exists and returns Dict[str, datetime]
3. `_action_from_plan()` function exists and returns Action from PlanHorizon
4. Decision loop calls `horizon_planner.plan()` before falling back to `optimizer.optimize()`
5. `store.update_plan(plan)` is called on successful LP solve
6. HolisticOptimizer.optimize() remains as fallback (not removed)
7. RL shadow path is unchanged
8. No syntax errors: `python -c "import main"` or `python -m py_compile main.py`
  </verify>
  <done>
- HorizonPlanner initialized at startup with graceful ImportError fallback
- Every decision cycle: planner.plan() called first, fallback to optimizer.optimize() on None
- _action_from_plan() converts LP slot-0 to Action for controller.apply()
- _get_departure_times() reads ev_charge_deadline_hour from config
- store.update_plan(plan) stores plan for dashboard/SSE
- Static ev_max_price_ct and battery_max_price_ct no longer gate decisions when LP succeeds (they are LP input bounds in planner.py, not main.py gates)
- RL shadow decision path is unchanged
  </done>
</task>

</tasks>

<verification>
1. main.py compiles without syntax errors
2. state_store.py compiles without syntax errors
3. HorizonPlanner is initialized in main.py startup
4. Decision loop prefers LP plan over holistic optimizer
5. Fallback chain works: when plan is None, optimizer.optimize() is called
6. StateStore stores and exposes plan via update_plan()/get_plan()
7. Static price limits removed from decision path (retained as LP input bounds only)
</verification>

<success_criteria>
- When HorizonPlanner returns a PlanHorizon, the controller receives LP-derived actions (not static price threshold actions)
- When HorizonPlanner returns None (solver failure, missing forecasts, scipy unavailable), the system falls back to HolisticOptimizer without crash
- StateStore.get_plan() returns the latest PlanHorizon after a successful cycle
- ev_charge_deadline_hour from config is used as the departure time input to the LP
- System never crashes due to planner failure — defensive try/except at every boundary
</success_criteria>

<output>
After completion, create `.planning/phases/04-predictive-planner/04-02-SUMMARY.md`
</output>

---
phase: 03-data-foundation
plan: 03
type: execute
wave: 2
depends_on: ["03-01", "03-02"]
files_modified:
  - evcc-smartload/rootfs/app/main.py
  - evcc-smartload/rootfs/app/state_store.py
  - evcc-smartload/rootfs/app/web/server.py
  - evcc-smartload/rootfs/app/web/static/app.js
  - evcc-smartload/rootfs/app/web/templates/dashboard.html
autonomous: false
requirements: [PLAN-04, PLAN-05]

must_haves:
  truths:
    - "ConsumptionForecaster and PVForecaster are initialized at startup and updated every decision cycle"
    - "StateStore snapshot includes forecast data (consumption_96, pv_96, pv_confidence, pv_correction_label, pv_quality_label, forecaster_ready, forecaster_data_days)"
    - "Dashboard shows 24h forecast graph with consumption line and PV line overlaid"
    - "Graph has price zone background colors (green=cheap, red=expensive) and battery phase colored areas (green=charge, orange=discharge)"
    - "Graph updates live via SSE when new forecast data arrives"
    - "Dashboard shows forecaster maturity progress indicator (e.g., 'Verbrauchsprognose: 5/14 Tage Daten')"
    - "Dashboard shows PV correction coefficient and forecast quality below PV graph"
    - "HA entity discovery runs at startup in a daemon thread and warnings appear in dashboard banner"
    - "GET /forecast endpoint returns JSON with all 96-slot forecast arrays"
  artifacts:
    - path: "evcc-smartload/rootfs/app/main.py"
      provides: "Forecaster initialization, update calls in decision loop, HA discovery thread"
      contains: "ConsumptionForecaster"
    - path: "evcc-smartload/rootfs/app/state_store.py"
      provides: "Extended update() and snapshot() with forecast fields"
      contains: "consumption_forecast"
    - path: "evcc-smartload/rootfs/app/web/server.py"
      provides: "GET /forecast endpoint returning JSON forecast data"
      contains: "/forecast"
    - path: "evcc-smartload/rootfs/app/web/static/app.js"
      provides: "renderForecastChart() function with SVG dual-line chart"
      contains: "renderForecastChart"
    - path: "evcc-smartload/rootfs/app/web/templates/dashboard.html"
      provides: "Forecast chart section, maturity indicator, PV labels, HA warning banner"
      contains: "forecastChart"
  key_links:
    - from: "evcc-smartload/rootfs/app/main.py"
      to: "evcc-smartload/rootfs/app/forecaster/consumption.py"
      via: "consumption_forecaster.update() and get_forecast_24h() in decision loop"
      pattern: "consumption_forecaster\\.update"
    - from: "evcc-smartload/rootfs/app/main.py"
      to: "evcc-smartload/rootfs/app/forecaster/pv.py"
      via: "pv_forecaster.refresh() hourly, update_correction() every cycle"
      pattern: "pv_forecaster\\.(refresh|update_correction)"
    - from: "evcc-smartload/rootfs/app/state_store.py"
      to: "evcc-smartload/rootfs/app/web/server.py"
      via: "snapshot() includes forecast fields read by /forecast endpoint"
      pattern: "consumption_forecast"
    - from: "evcc-smartload/rootfs/app/web/static/app.js"
      to: "evcc-smartload/rootfs/app/web/server.py"
      via: "fetch('/forecast') and SSE forecast updates"
      pattern: "fetch.*forecast"
    - from: "evcc-smartload/rootfs/app/web/static/app.js"
      to: "evcc-smartload/rootfs/app/web/templates/dashboard.html"
      via: "SVG rendering into #forecastChart container"
      pattern: "forecastChart"
---

<objective>
Wire both forecasters into the main decision loop, extend StateStore with forecast data, add the /forecast API endpoint, and build the 24h SVG forecast chart with SSE live updates on the dashboard.

Purpose: This plan integrates the standalone forecaster modules (from Plans 01 and 02) into the running system: main.py initializes and calls them, StateStore carries their output to the web layer, and the dashboard renders the 24h forecast graph with all user-specified visual elements (price zones, battery phases, PV correction label, maturity indicator).

Output: Complete end-to-end forecast pipeline from InfluxDB/evcc API through to live dashboard visualization.
</objective>

<execution_context>
@C:/Users/nicok/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/nicok/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-data-foundation/03-RESEARCH.md
@.planning/phases/03-data-foundation/03-CONTEXT.md
@.planning/phases/01-state-infrastructure/01-01-SUMMARY.md
@.planning/phases/03-data-foundation/03-01-SUMMARY.md
@.planning/phases/03-data-foundation/03-02-SUMMARY.md

@evcc-smartload/rootfs/app/main.py
@evcc-smartload/rootfs/app/state_store.py
@evcc-smartload/rootfs/app/web/server.py
@evcc-smartload/rootfs/app/web/static/app.js
@evcc-smartload/rootfs/app/web/templates/dashboard.html
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire forecasters into main loop and extend StateStore</name>
  <files>
    evcc-smartload/rootfs/app/main.py
    evcc-smartload/rootfs/app/state_store.py
  </files>
  <action>
**1. `main.py` — forecaster initialization and decision loop integration:**

**Imports (add near top):**
```python
from forecaster import ConsumptionForecaster, PVForecaster
from forecaster.ha_energy import run_entity_discovery
```

**Initialization (after config validation, before main loop):**

- Create `consumption_forecaster = ConsumptionForecaster(influx, cfg)` after `influx = InfluxDBClient(cfg)` is created
- Create `pv_forecaster = PVForecaster(evcc)` after `evcc = EvccClient(cfg)` is created
- Start HA entity discovery in a daemon thread (non-blocking, per Research Pitfall 3):
  ```python
  ha_discovery_result = {"status": "pending"}
  if cfg.ha_url and cfg.ha_token:
      import threading
      def _ha_discover():
          ha_discovery_result.update(run_entity_discovery(cfg.ha_url, cfg.ha_token))
      threading.Thread(target=_ha_discover, daemon=True).start()
  ```
- Do an initial PV forecast refresh: `pv_forecaster.refresh()` (first fetch before loop starts)
- Track PV refresh timing: `_last_pv_refresh = time.time()`

**Inside the main decision loop (after state is collected, before store.update):**

After the state enrichment block (price percentiles, solar forecast, etc.):

1. **Update ConsumptionForecaster every cycle (15 min):**
   ```python
   if state and state.home_power is not None:
       consumption_forecaster.update(state.home_power, datetime.now(timezone.utc))
       # Immediate self-correction: compare actual vs forecast for current slot
       current_forecast = consumption_forecaster.get_forecast_24h()
       if current_forecast and current_forecast[0] > 100:
           consumption_forecaster.apply_correction(state.home_power, current_forecast[0])
   ```

2. **Refresh PV forecast hourly:**
   ```python
   if time.time() - _last_pv_refresh > 3600:  # 1 hour
       pv_forecaster.refresh()
       _last_pv_refresh = time.time()
   ```

3. **Update PV correction coefficient every cycle:**
   ```python
   if state and state.pv_power is not None:
       pv_kw = state.pv_power / 1000.0 if state.pv_power > 100 else state.pv_power
       pv_forecaster.update_correction(pv_kw, datetime.now(timezone.utc))
   ```

4. **Collect forecast data for StateStore:**
   ```python
   consumption_96 = consumption_forecaster.get_forecast_24h() if consumption_forecaster.is_ready else None
   pv_96 = pv_forecaster.get_forecast_24h()
   ```

**Update the `store.update()` call** to pass forecast data:
```python
store.update(
    state=state,
    lp_action=lp_action,
    rl_action=rl_action,
    solar_forecast=solar_forecast,
    consumption_forecast=consumption_96,
    pv_forecast=pv_96,
    pv_confidence=pv_forecaster.confidence,
    pv_correction_label=pv_forecaster.correction_label,
    pv_quality_label=pv_forecaster.quality_label,
    forecaster_ready=consumption_forecaster.is_ready,
    forecaster_data_days=consumption_forecaster.data_days,
    ha_warnings=ha_discovery_result.get("warnings", []),
)
```

**Cold start behavior (per user decision):**
- When `not consumption_forecaster.is_ready`: log "Verbrauchsprognose nicht bereit ({data_days}/1 Tage Daten), verwende Standardwerte"
- The planner (Phase 4) will check `forecaster_ready` in StateStore to decide whether to use forecasts or defaults

**2. `state_store.py` — extend with forecast fields:**

**Update `__init__`:** Add new fields under the lock section:
```python
self._consumption_forecast: Optional[List[float]] = None
self._pv_forecast: Optional[List[float]] = None
self._pv_confidence: float = 0.0
self._pv_correction_label: str = ""
self._pv_quality_label: str = ""
self._forecaster_ready: bool = False
self._forecaster_data_days: int = 0
self._ha_warnings: List[str] = []
```

**Update `update()` signature** to accept new keyword arguments:
```python
def update(self, state, lp_action, rl_action, solar_forecast=None,
           consumption_forecast=None, pv_forecast=None,
           pv_confidence=0.0, pv_correction_label="",
           pv_quality_label="", forecaster_ready=False,
           forecaster_data_days=0, ha_warnings=None):
```
Inside the lock: update all new fields.

**Update `_snapshot_unlocked()`** to include new fields:
```python
"consumption_forecast": list(self._consumption_forecast) if self._consumption_forecast else None,
"pv_forecast": list(self._pv_forecast) if self._pv_forecast else None,
"pv_confidence": self._pv_confidence,
"pv_correction_label": self._pv_correction_label,
"pv_quality_label": self._pv_quality_label,
"forecaster_ready": self._forecaster_ready,
"forecaster_data_days": self._forecaster_data_days,
"ha_warnings": list(self._ha_warnings) if self._ha_warnings else [],
```

**Update `_snapshot_to_json_dict()`** to include forecast data in SSE payload:
Add a `"forecast"` section to the returned dict:
```python
"forecast": {
    "consumption_96": snap.get("consumption_forecast"),
    "pv_96": snap.get("pv_forecast"),
    "pv_confidence": snap.get("pv_confidence", 0.0),
    "pv_correction_label": snap.get("pv_correction_label", ""),
    "pv_quality_label": snap.get("pv_quality_label", ""),
    "forecaster_ready": snap.get("forecaster_ready", False),
    "forecaster_data_days": snap.get("forecaster_data_days", 0),
    "ha_warnings": snap.get("ha_warnings", []),
},
```

This ensures SSE broadcasts include forecast data so the dashboard chart updates live per user decision.

IMPORTANT: Maintain the existing pattern where broadcast happens OUTSIDE the RLock. The new fields are just additional data in the same atomic update. Do NOT create a separate lock for forecast data — it all goes through the single RLock for atomic snapshots.
  </action>
  <verify>
1. grep for `ConsumptionForecaster` in `main.py` confirms import and initialization
2. grep for `PVForecaster` in `main.py` confirms import and initialization
3. grep for `consumption_forecaster.update` in `main.py` confirms per-cycle update
4. grep for `pv_forecaster.refresh` in `main.py` confirms hourly refresh
5. grep for `pv_forecaster.update_correction` in `main.py` confirms per-cycle correction
6. grep for `consumption_forecast` in `state_store.py` confirms new field in snapshot
7. grep for `pv_forecast` in `state_store.py` confirms new field in snapshot
8. grep for `"forecast"` in `state_store.py` confirms forecast section in SSE JSON
9. grep for `ha_warnings` in `state_store.py` confirms HA warnings in snapshot
10. grep for `run_entity_discovery` in `main.py` confirms HA discovery thread
  </verify>
  <done>
Both forecasters initialized at startup and called every decision cycle. StateStore extended with consumption_forecast (96 floats), pv_forecast (96 floats), pv_confidence, pv_correction_label, pv_quality_label, forecaster_ready, forecaster_data_days, ha_warnings. SSE payload includes all forecast data. HA entity discovery runs in daemon thread at startup. Cold start logged in German.
  </done>
</task>

<task type="auto">
  <name>Task 2: Dashboard forecast chart, API endpoint, and SSE integration</name>
  <files>
    evcc-smartload/rootfs/app/web/server.py
    evcc-smartload/rootfs/app/web/static/app.js
    evcc-smartload/rootfs/app/web/templates/dashboard.html
  </files>
  <action>
**1. `web/server.py` — add GET /forecast endpoint:**

Add a new handler in `do_GET` for path `/forecast`:
```python
elif path == "/forecast":
    snap = self._store.snapshot()
    forecast_data = {
        "consumption_96": snap.get("consumption_forecast"),
        "pv_96": snap.get("pv_forecast"),
        "pv_confidence": snap.get("pv_confidence", 0.0),
        "pv_correction_label": snap.get("pv_correction_label", ""),
        "pv_quality_label": snap.get("pv_quality_label", ""),
        "forecaster_ready": snap.get("forecaster_ready", False),
        "forecaster_data_days": snap.get("forecaster_data_days", 0),
        "ha_warnings": snap.get("ha_warnings", []),
        "price_zones_96": self._compute_price_zones(snap),
    }
    self._send_json(forecast_data)
```

Add helper `_compute_price_zones(self, snap) -> list`:
- Uses `snap["state"].price_percentiles` (if available) and the solar_forecast tariff data
- For each of the 96 fifteen-min slots in the next 24h, classify as "cheap" (below P30), "normal" (P30-P60), or "expensive" (above P60)
- Return list of 96 strings: "cheap", "normal", "expensive"
- If price data not available: return list of 96 "normal" strings

**2. `web/templates/dashboard.html` — add forecast chart section and indicators:**

Add a new section AFTER the existing main content cards, BEFORE any closing tags:

**HA Warning Banner (at top of page, conditional):**
```html
<div id="haWarningBanner" class="ha-warning-banner" style="display:none;">
    <span class="warning-icon">&#9888;</span>
    <span id="haWarningText"></span>
</div>
```

**Forecast Chart Section:**
```html
<div class="card forecast-card">
    <h3>24h Prognose</h3>
    <div class="forecast-meta">
        <span id="forecasterMaturity" class="forecast-maturity"></span>
        <span id="pvQualityLabel" class="forecast-quality"></span>
        <span id="pvCorrectionLabel" class="forecast-correction"></span>
    </div>
    <div id="forecastChart" class="forecast-chart-container">
        <!-- SVG chart rendered by app.js -->
    </div>
</div>
```

**CSS styles (add to dashboard.html `<style>` or style.css):**
- `.ha-warning-banner`: yellow/amber background, dark text, full-width banner, padding 8px 16px
- `.forecast-card`: same card style as existing status cards (dark background, border-radius, padding)
- `.forecast-chart-container`: width 100%, height 250px, overflow hidden
- `.forecast-meta`: flex row, gap 16px, font-size 0.85em, color #888
- `.forecast-maturity`: italic, shows data collection progress
- `.forecast-quality`, `.forecast-correction`: subtle secondary text

**3. `web/static/app.js` — add renderForecastChart() and SSE integration:**

**Add `renderForecastChart(data)` function:**

This renders a pure SVG chart (no external libraries — matching existing dashboard pattern) inside `#forecastChart`:

SVG dimensions: viewBox `0 0 960 250`. Margins: top=20, right=20, bottom=30, left=50.

Chart elements (layered back to front):
1. **Price zone background rectangles:** For each slot, draw a thin rect (10px wide per slot) with fill color based on price zone:
   - "cheap": `rgba(0, 255, 136, 0.08)` (green, very subtle — per user decision)
   - "expensive": `rgba(255, 68, 68, 0.06)` (red, very subtle — per user decision)
   - "normal": transparent (no rect)

2. **Battery phase colored areas** (placeholder for Phase 4 data — draw if `battery_phases_96` exists in data):
   - Charge: `rgba(0, 255, 136, 0.15)` (green — per user decision)
   - Discharge: `rgba(255, 170, 0, 0.15)` (orange — per user decision)
   - For now, since Phase 4 doesn't exist yet, skip this layer if data.battery_phases_96 is undefined

3. **Consumption forecast line** (blue `#00d4ff` per user/research decision):
   - SVG `<path>` element with stroke `#00d4ff`, fill none, stroke-width 2
   - Plot data.consumption_96 as Watts on Y-axis, 96 slots on X-axis
   - Use `d="M x0,y0 L x1,y1 L x2,y2 ..."` path

4. **PV forecast line** (yellow `#ffdd00` per user/research decision):
   - SVG `<path>` element with stroke `#ffdd00`, fill none, stroke-width 2
   - Plot data.pv_96 as kW*1000 (convert to Watts for same Y-axis) on Y-axis
   - Show as area fill with low opacity `rgba(255, 221, 0, 0.1)` below the line

5. **Axes:**
   - X-axis: time labels every 3 hours (00:00, 03:00, ..., 21:00), relative to current time
   - Y-axis: Watt labels (0, 1000, 2000, etc.), auto-scaled to max of both datasets
   - Grid lines: subtle horizontal dashed lines at Y-axis ticks

6. **Legend:** Small inline legend below chart: blue square "Verbrauch", yellow square "PV-Ertrag"

**Add `updateForecastMeta(data)` function:**
- Set `#forecasterMaturity` text: If `data.forecaster_ready`: "Verbrauchsprognose: {data_days}/14 Tage Daten" else "Verbrauchsprognose: {data_days}/14 Tage Daten, Genauigkeit steigt noch" (per user decision — show maturity progress)
- Set `#pvQualityLabel` text: `data.pv_quality_label` (e.g., "Basierend auf 18h Forecast-Daten")
- Set `#pvCorrectionLabel` text: `data.pv_correction_label` (e.g., "Korrektur: +13%")

**Add `updateHaWarnings(warnings)` function:**
- If warnings array is non-empty: show `#haWarningBanner`, set text with joined warnings
- If empty: hide banner

**SSE integration — extend existing `applySSEUpdate(msg)` function:**
- Check if `msg.forecast` exists in SSE payload
- If yes: call `renderForecastChart(msg.forecast)`, `updateForecastMeta(msg.forecast)`, `updateHaWarnings(msg.forecast.ha_warnings || [])`
- This provides live graph updates via SSE per user decision

**Initial load — extend startup:**
- On page load, `fetch('/forecast')` to get initial data
- Call `renderForecastChart(data)`, `updateForecastMeta(data)`, `updateHaWarnings(data.ha_warnings || [])`

IMPORTANT: Use pure SVG (no Plotly, no Chart.js, no D3 — matching existing dashboard pattern from Research). Match the dark theme of the existing dashboard. All German text for labels. The chart must work in all modern browsers without external JS dependencies.
  </action>
  <verify>
1. grep for `/forecast` in `web/server.py` confirms new endpoint
2. grep for `renderForecastChart` in `web/static/app.js` confirms SVG chart function
3. grep for `forecastChart` in `web/templates/dashboard.html` confirms chart container
4. grep for `forecasterMaturity` in `web/templates/dashboard.html` confirms maturity indicator
5. grep for `pvCorrectionLabel` in `web/templates/dashboard.html` confirms correction display
6. grep for `pvQualityLabel` in `web/templates/dashboard.html` confirms quality display
7. grep for `haWarningBanner` in `web/templates/dashboard.html` confirms HA warning banner
8. grep for `#00d4ff` in `web/static/app.js` confirms consumption line color per spec
9. grep for `#ffdd00` in `web/static/app.js` confirms PV line color per spec
10. grep for `fetch.*forecast` in `web/static/app.js` confirms initial data load
11. grep for `msg.forecast` or `forecast` in `web/static/app.js` confirms SSE integration
  </verify>
  <done>
GET /forecast endpoint returns JSON with consumption_96, pv_96, price_zones_96, and all metadata. Dashboard has SVG 24h forecast chart with consumption (blue #00d4ff) and PV (yellow #ffdd00) lines, price zone backgrounds, battery phase areas (placeholder for Phase 4). Maturity indicator shows "X/14 Tage Daten". PV correction and quality labels displayed. HA warning banner shown when unconfigured entities detected. Chart updates live via SSE.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 3: Verify dashboard forecast visualization</name>
  <what-built>
Complete forecast pipeline: ConsumptionForecaster (InfluxDB history) and PVForecaster (evcc solar tariff) wired into main loop, StateStore extended with forecast data, /forecast API endpoint, 24h SVG forecast chart on dashboard with SSE live updates, forecaster maturity indicator, PV correction/quality labels, HA entity warning banner.
  </what-built>
  <how-to-verify>
1. Start the add-on container
2. Open the dashboard at http://[host]:8099
3. Verify the 24h forecast chart section appears below the status cards
4. Check that the chart shows:
   - Blue line for consumption forecast (or flat line at 1200W if cold start)
   - Yellow line for PV forecast (or empty if nighttime/no evcc solar data)
   - Subtle colored backgrounds for price zones (green=cheap, red=expensive)
   - Legend below chart: "Verbrauch" and "PV-Ertrag"
5. Check metadata below chart:
   - Forecaster maturity: "Verbrauchsprognose: X/14 Tage Daten, Genauigkeit steigt noch" (if new install)
   - PV quality label: "Basierend auf Xh Forecast-Daten" (or "Kein PV-Forecast verfuegbar")
   - PV correction label: "Korrektur: +X%" (or empty if no correction data yet)
6. Visit http://[host]:8099/forecast — verify JSON response with consumption_96, pv_96 arrays
7. Wait for SSE update (or trigger a decision cycle) — verify chart refreshes without page reload
8. Check container logs for:
   - "PV forecast: Xh coverage, correction=X.XX" (hourly)
   - HA entity warnings if HA is configured (or no warnings if not)
   - "Verbrauchsprognose nicht bereit" if fresh install (cold start)
  </how-to-verify>
  <resume-signal>Type "approved" or describe any visual/functional issues</resume-signal>
</task>

</tasks>

<verification>
- main.py creates both forecasters at startup and calls them in the decision loop
- StateStore carries all forecast fields through to web layer
- /forecast endpoint returns complete forecast JSON
- Dashboard chart renders with correct colors and overlaid lines
- SSE pushes forecast updates to connected browsers
- Cold start behavior: maturity indicator shows progress, forecaster returns defaults
- All text on dashboard is in German
</verification>

<success_criteria>
- End-to-end forecast pipeline works: InfluxDB/evcc -> forecasters -> StateStore -> /forecast API -> dashboard chart
- Chart visually matches spec: blue consumption line, yellow PV line, price zone backgrounds, battery phase areas
- SSE delivers live chart updates without page reload
- Maturity indicator accurately shows data collection progress
- PV labels (correction, quality) display correct German text
- HA warnings appear in dashboard banner when applicable
- GET /forecast returns valid JSON with 96-slot arrays
</success_criteria>

<output>
After completion, create `.planning/phases/03-data-foundation/03-03-SUMMARY.md`
</output>

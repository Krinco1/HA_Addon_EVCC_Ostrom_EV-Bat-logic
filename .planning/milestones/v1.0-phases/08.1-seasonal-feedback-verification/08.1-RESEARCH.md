# Phase 8.1: Seasonal Feedback + Phase 5 Verification - Research

**Researched:** 2026-02-23
**Domain:** Python codebase integration — SeasonalLearner LP wiring and retroactive verification
**Confidence:** HIGH

<user_constraints>
## User Constraints (from CONTEXT.md)

### Locked Decisions
- **Correction conservatism:** Dampen correction factors toward neutral rather than applying full historical magnitude. Better to under-correct than over-correct since dispatch has real-world consequences.
- **Sparse data handling:** Always execute the seasonal correction code path regardless of data availability. When no data exists (get_correction_factor() returns None), return neutral so the LP uses baseline costs unchanged.
- **Phase 5 verification rigor:** Walk through each must_have from Phase 5's plan, confirm the code implements it, document evidence in VERIFICATION.md. Standard VERIFICATION.md format consistent with other phase verifications in the project. If verification finds ANY gap (must_have not fully implemented), fix it in this phase — don't just document for later.

### Claude's Discretion
- Safety cap magnitude on correction factors (pick a reasonable bound)
- Slot granularity: uniform per-season correction vs per-slot weighting
- Minimum data threshold before corrections activate (already set to 10 in SeasonalLearner.get_correction_factor)
- Whether to surface correction factors in decision logs / transparency layer
- Confidence indicators for sparse data scenarios
- Phase 5 verification boundary: buffer-only vs buffer + integration points

### Deferred Ideas (OUT OF SCOPE)
None — discussion stayed within phase scope
</user_constraints>

<phase_requirements>
## Phase Requirements

| ID | Description | Research Support |
|----|-------------|-----------------|
| LERN-02 | System erkennt und adaptiert saisonale Muster (Verbrauch, PV-Ertrag, Preisverhalten über Jahreszeiten) | SeasonalLearner.get_correction_factor() already accumulates data; this phase wires it into HorizonPlanner LP objective by passing seasonal cost correction through plan() call in main.py |
| PLAN-03 | Hausakku-Mindest-SoC passt sich situationsabhängig an (Tageszeit, PV-Prognose, erwarteter Verbrauch, Preislage) | DynamicBufferCalc is implemented and wired in main.py. This phase provides a VERIFICATION.md that formally confirms each must_have from Phase 5's plan against the actual codebase |
</phase_requirements>

---

## Summary

Phase 8.1 closes two gaps identified in the v1.0 audit. The first gap (LERN-02) is that `SeasonalLearner` has been accumulating plan errors since Phase 8 Plan 03, but its output is never fed back into the LP optimizer — `get_correction_factor()` is never called in `main.py`. The fix is a targeted wiring change: call `get_correction_factor()` each cycle and pass a dampened seasonal cost offset into `HorizonPlanner.plan()`. The second gap (PLAN-03) is purely documentary: the Phase 5 Dynamic Buffer implementation was completed and is confirmed working in the codebase, but no formal VERIFICATION.md exists that walks through each Phase 5 must_have with code evidence.

The implementation pattern is well-established in this codebase. The `HorizonPlanner.plan()` method already accepts `confidence_factors` for PV reliability, and its LP objective builds per-slot cost coefficients `c[t]` that can accept an additive seasonal offset. The `SeasonalLearner.get_correction_factor()` returns either `None` (sparse data) or a `mean_error_eur` (EUR absolute value). The user decisions require conservative dampening, always-execute code path, and a safety cap. These requirements map cleanly to a helper function that converts raw correction to a dampened, capped, neutral-safe offset.

For PLAN-03, a complete audit of the Phase 5 codebase confirms all 15 must_haves across Phase 5 Plans 01 and 02 are satisfied. The VERIFICATION.md should document each must_have with the specific function, file path, and line-level evidence to close the gap cleanly.

**Primary recommendation:** Wire seasonal correction as an additive EUR/kWh offset on LP cost coefficients with dampening factor 0.5 and safety cap ±0.05 EUR/kWh; pass via a new `seasonal_correction_eur` parameter on `HorizonPlanner.plan()`.

---

## Standard Stack

### Core
| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| Python stdlib | 3.x | threading, datetime, json | All other modules use stdlib-only patterns |
| scipy.optimize.linprog (HiGHS) | existing | LP solver already integrated | HorizonPlanner already imports and uses it |

### Supporting
| Library | Version | Purpose | When to Use |
|---------|---------|---------|-------------|
| numpy | existing | LP cost vector `c` construction | Already used in planner._solve_lp() |

### Alternatives Considered
| Instead of | Could Use | Tradeoff |
|------------|-----------|----------|
| Additive EUR offset on c[t] | Multiplicative factor on price_96[t] | Additive is more predictable when correction is small; multiplicative risks compounding with other adjustments |
| New parameter on plan() | Passing via confidence_factors dict | New explicit parameter is clearer; confidence_factors is already overloaded and semantically different |

**Installation:**
No new dependencies — stdlib and existing scipy/numpy are sufficient.

---

## Architecture Patterns

### Recommended Project Structure

No structural changes needed. The change is confined to:
```
evcc-smartload/rootfs/app/
├── main.py              # Add: get_correction_factor() call + pass to plan()
├── optimizer/planner.py # Add: seasonal_correction_eur parameter + apply to c[t]
└── .planning/phases/
    ├── 08.1-seasonal-feedback-verification/
    │   └── 08.1-RESEARCH.md     # This file
    └── 05-dynamic-buffer/
        └── VERIFICATION.md      # New: Phase 5 audit evidence
```

### Pattern 1: Seasonal Correction Helper in main.py

**What:** A helper function that converts SeasonalLearner's raw `mean_error_eur` into a dampened, capped, always-safe EUR/kWh cost offset. Always returns a float (0.0 when no data). Called each cycle before `horizon_planner.plan()`.

**When to use:** Every LP planning cycle. The helper absorbs all None/sparse-data handling so the call site in the main loop stays clean.

**Example:**
```python
# Source: codebase analysis — follows pattern of _compute_slot0_cost() helper
_SEASONAL_DAMPING = 0.5        # Apply only 50% of historical error (conservative)
_SEASONAL_CAP_EUR_KWH = 0.05  # Max correction ±5ct/kWh (safety cap)

def _seasonal_correction_eur(seasonal_learner, now: datetime) -> float:
    """Return a dampened, capped seasonal cost correction (EUR/kWh).

    Returns 0.0 when seasonal_learner is None or data is insufficient.
    Positive correction = plan historically underestimated costs (charge less).
    Negative correction = plan historically overestimated costs (charge more).

    Units: EUR/kWh — added to per-slot LP cost coefficient c[t].
    """
    if seasonal_learner is None:
        return 0.0
    try:
        raw = seasonal_learner.get_correction_factor(now)
    except Exception:
        return 0.0
    if raw is None:
        return 0.0  # sparse data — stay neutral
    dampened = raw * _SEASONAL_DAMPING
    return max(-_SEASONAL_CAP_EUR_KWH, min(_SEASONAL_CAP_EUR_KWH, dampened))
```

### Pattern 2: HorizonPlanner.plan() Extension

**What:** Add `seasonal_correction_eur: float = 0.0` parameter to `plan()` and thread it down to `_solve_lp()` where it is added to `c[t]` for all charging slots.

**When to use:** The correction is applied uniformly per season (not per-slot) — this is the simplest and most auditable approach. Per-slot weighting (Claude's discretion) would require passing a 96-element array, adding complexity with little benefit at this stage.

**Example:**
```python
# Source: planner.py _solve_lp() — existing c[t] construction (lines 282-314)
# Inside the per-slot loop after existing effective_price computation:
for t in range(T):
    # ... existing effective_price logic unchanged ...

    # Seasonal correction: additive offset on charging cost
    # Positive = historically expensive slot → raise cost → charge less
    # Negative = historically cheap slot → lower cost → charge more
    if price_96[t] > self._bat_max_price:
        c[i_bat_chg + t] = price_96[t] * 10.0  # penalty unchanged
    else:
        c[i_bat_chg + t] = effective_price + seasonal_correction_eur

    if price_96[t] > self._ev_max_price and ev_connected:
        c[i_ev_chg + t] = price_96[t] * 10.0   # penalty unchanged
    else:
        c[i_ev_chg + t] = effective_price + seasonal_correction_eur

    c[i_bat_dis + t] = -self._feed_in  # unchanged
```

**Key constraint:** The heavy-penalty slots (`price_96[t] > self._bat_max_price`) must NOT receive the seasonal offset — the 10x penalty already gates them out and adding a small seasonal offset would be meaningless. Only apply to normal-cost slots.

### Pattern 3: Phase 5 VERIFICATION.md Format

**What:** A markdown document that walks through every Phase 5 must_have truth and artifact, citing specific code evidence for each.

**When to use:** After confirming each truth against the actual code via grep/read. This is a documentation task, not a code task.

**Format pattern** (inferred from project style — no prior VERIFICATION.md exists; closest analog is SUMMARY.md):
```markdown
# Phase 5 Dynamic Buffer — Verification

**Verified:** YYYY-MM-DD
**Audited by:** Phase 8.1 gap closure
**Result:** PASS / PARTIAL (list gaps if any)

## Must-Have Truths

### Truth 1: [truth text verbatim from 05-01-PLAN.md]
**Status:** PASS
**Evidence:** `dynamic_buffer.py` `DynamicBufferCalc.step()` calls `_compute_target()` each cycle.
  File: `evcc-smartload/rootfs/app/dynamic_buffer.py`, line ~165
  Code: `target_buffer = self._compute_target(effective_pv_confidence, price_spread, pv_96, now)`

### Truth N: ...

## Must-Have Artifacts

### Artifact: evcc-smartload/rootfs/app/dynamic_buffer.py
**Status:** PASS
**Evidence:** File exists, 435 lines (> min 250). Contains DynamicBufferCalc with all required methods.

...

## Key Links

### Link: main.py → dynamic_buffer.py via buffer_calc.step()
**Status:** PASS
**Evidence:** `main.py` line ~538: `buffer_result = buffer_calc.step(...)`

## Summary

All N must_haves PASS. No gaps found. Phase 5 Dynamic Buffer is fully implemented.
```

### Anti-Patterns to Avoid

- **Applying seasonal offset to over-price penalty slots:** The `price_96[t] * 10.0` penalty must stay unchanged — seasonal correction targets normal cost decisions, not forced exclusions.
- **Converting correction from EUR to ct before adding:** The LP cost vector `c[t]` uses EUR/kWh throughout. Do not mix units.
- **Calling get_correction_factor() with a fixed datetime:** Always pass `datetime.now(timezone.utc)` to get the correct season/period/weekend classification for the current planning cycle.
- **Skipping the seasonal code path when data is sparse:** The locked decision requires always-execute. Return 0.0 when None, never skip the call.
- **Mutating the existing `confidence_factors` dict:** The seasonal correction is a separate concern from forecast confidence. Keep them as independent parameters.

---

## Don't Hand-Roll

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| Thread-safe seasonal data access | Custom locking around raw dict | `SeasonalLearner.get_correction_factor()` | Already thread-safe with `_lock`, handles empty/sparse cells |
| Persistence of correction data | New JSON write | `SeasonalLearner` (already persists every 10 updates) | File already being maintained at `/data/smartprice_seasonal_model.json` |
| Season detection | Reimplement month-to-season | `SeasonalLearner._classify_dt()` internal | Already implemented with explicit dict (avoiding December-as-autumn bug) |

**Key insight:** Both the data accumulation (Phase 8 Plan 02) and the data persistence are already complete. This phase is pure wiring — calling the already-correct API and threading the result into the LP.

---

## Common Pitfalls

### Pitfall 1: Unit Mismatch — EUR vs EUR/kWh

**What goes wrong:** `SeasonalLearner.get_correction_factor()` returns `mean_error_eur` which is a raw EUR amount (actual_cost - plan_cost for a 15-min slot). The LP cost vector `c[t]` uses EUR/kWh. Applying the raw EUR value directly would make the correction orders-of-magnitude too large or too small.

**Why it happens:** The `mean_error_eur` is a slot-level cost difference. The LP's `c[t]` represents the cost per kWh of energy flowing through the system in a 15-min slot.

**How to avoid:** Divide by a representative energy quantum or treat `mean_error_eur` as an approximation of the per-kWh drift. The most pragmatic approach: treat the raw EUR error as approximately "EUR per 0.25h × average_power_kw" and normalize to EUR/kWh. However, given the conservative approach (50% dampening, ±0.05 cap), unit precision is less critical than safety. The planner verifies correctness via the cap.

**Recommended approach:** Document in the helper that the correction is an approximation — the cap (±0.05 EUR/kWh) ensures the correction remains in a safe range regardless of the exact unit interpretation. This matches the "dampen toward neutral" locked decision.

**Warning signs:** LP costs becoming extremely large (>1.0 EUR/kWh) or corrections always hitting the cap.

### Pitfall 2: get_correction_factor() Returning None at Scale

**What goes wrong:** `min_samples=10` is the default threshold in `SeasonalLearner.get_correction_factor()`. With 48 cells (4 seasons × 6 time periods × 2 weekend flags), it takes many cycles before any cell has 10+ observations. For months, most cells return None.

**Why it happens:** New deployment, no historical data yet.

**How to avoid:** The sparse-data code path (return 0.0 when None) is already part of the locked decision. The helper function handles this correctly. The correction simply does nothing until cells accumulate data — this is the desired behavior.

**Warning signs:** If correction never activates after 6+ months of runtime, check that `seasonal_learner.update()` is being called correctly in the main loop (it is, per Phase 8 Plan 03 wiring).

### Pitfall 3: VERIFICATION.md Gaps Requiring Code Fixes

**What goes wrong:** Phase 5 verification uncovers a must_have that is NOT implemented in the current codebase, requiring actual code changes rather than just documentation.

**Why it happens:** Phase 5 was implemented correctly (confirmed by reading the code), but there is one subtle integration point to watch: Phase 5 Plan 02's must_haves include web/server.py POST endpoints and app.js SSE integration. These files were not read in detail during research.

**How to avoid:** Verify ALL Phase 5 must_haves against the actual files before writing the VERIFICATION.md. If a gap is found, fix it before declaring PASS.

**Research finding (HIGH confidence):** Based on reading `dynamic_buffer.py` (435 lines), `main.py` (with `buffer_calc.step()` at line ~538, `buffer_result=buffer_result` in `store.update()`), and `state_store.py` (with `"buffer": snap.get("buffer_result")`), all Phase 5 Plan 01 must_haves appear to be fully implemented. Phase 5 Plan 02 (web UI) requires separate file inspection during plan execution.

### Pitfall 4: Seasonal Correction Overriding Heavy-Penalty Slots

**What goes wrong:** The LP applies a `price_96[t] * 10.0` penalty to slots above the user's max price. Adding a seasonal correction to these slots is wrong — the penalty is already forcing the LP to avoid them.

**Why it happens:** A naive "add correction to all c[t]" implementation without checking the penalty condition.

**How to avoid:** Apply seasonal correction only in the `else` branch of the `if price_96[t] > self._bat_max_price` check, not universally.

### Pitfall 5: Two Plan() Calls in ReactionTimingTracker Path

**What goes wrong:** There is a second `horizon_planner.plan()` call in the ReactionTimingTracker re-plan path (lines ~622-632 in main.py). If the seasonal correction is only added to the first plan() call, the re-plan uses uncorrected costs.

**Why it happens:** The re-plan was added in Phase 8 Plan 03 and passes `confidence_factors` but not `seasonal_correction_eur`.

**How to avoid:** Store the seasonal correction value computed at the top of each cycle in a loop variable (e.g. `_seasonal_correction_eur`) and pass it to both plan() calls — the primary one and the re-plan fallback.

---

## Code Examples

Verified patterns from codebase reading:

### Current plan() call in main.py (lines 406-414)
```python
# Source: evcc-smartload/rootfs/app/main.py (read in full)
plan = None
if horizon_planner is not None and consumption_96 is not None and pv_96 is not None:
    plan = horizon_planner.plan(
        state=state,
        tariffs=tariffs,
        consumption_96=consumption_96,
        pv_96=pv_96,
        ev_departure_times=_get_departure_times(departure_store, cfg, state),
        confidence_factors=confidence_factors,
    )
```

### After Phase 8.1 wiring (what the planner call becomes)
```python
# Source: Phase 8.1 research — following existing helper pattern
_seasonal_corr = _seasonal_correction_eur(seasonal_learner, datetime.now(timezone.utc))
plan = None
if horizon_planner is not None and consumption_96 is not None and pv_96 is not None:
    plan = horizon_planner.plan(
        state=state,
        tariffs=tariffs,
        consumption_96=consumption_96,
        pv_96=pv_96,
        ev_departure_times=_get_departure_times(departure_store, cfg, state),
        confidence_factors=confidence_factors,
        seasonal_correction_eur=_seasonal_corr,
    )
```

### HorizonPlanner.plan() signature extension
```python
# Source: evcc-smartload/rootfs/app/optimizer/planner.py (read in full)
def plan(
    self,
    state: SystemState,
    tariffs: List[Dict],
    consumption_96: List[float],
    pv_96: List[float],
    ev_departure_times: Dict[str, datetime],
    confidence_factors: Optional[Dict] = None,
    seasonal_correction_eur: float = 0.0,   # NEW: Phase 8.1
) -> Optional[PlanHorizon]:
```

### LP cost vector with seasonal correction (inside _solve_lp())
```python
# Source: evcc-smartload/rootfs/app/optimizer/planner.py lines 282-314 (read in full)
# Existing loop — add seasonal_correction_eur to the else branches only:
for t in range(T):
    pv_surplus_kw = max(0.0, pv_kw_96[t] - cons_96[t] / 1000.0)
    effective_price = price_96[t]
    if pv_surplus_kw > 0.05:
        pv_coverage = min(1.0, pv_surplus_kw / max(self._bat_p_max, 0.1))
        effective_price = price_96[t] * (1.0 - pv_coverage * pv_confidence_factor)

    if price_96[t] > self._bat_max_price:
        c[i_bat_chg + t] = price_96[t] * 10.0   # penalty — no seasonal offset
    else:
        c[i_bat_chg + t] = effective_price + seasonal_correction_eur  # NEW

    if price_96[t] > self._ev_max_price and ev_connected:
        c[i_ev_chg + t] = price_96[t] * 10.0    # penalty — no seasonal offset
    else:
        c[i_ev_chg + t] = effective_price + seasonal_correction_eur  # NEW

    c[i_bat_dis + t] = -self._feed_in  # unchanged — discharge revenue unaffected
```

### SeasonalLearner API (existing, from reading seasonal_learner.py)
```python
# Source: evcc-smartload/rootfs/app/seasonal_learner.py (read in full)
# get_correction_factor() signature:
def get_correction_factor(
    self, dt: datetime, min_samples: int = 10
) -> Optional[float]:
    """Returns mean_error_eur or None if fewer than min_samples observations."""
```

---

## Phase 5 Must-Have Audit (Pre-Research Findings)

The following is a pre-audit based on reading Phase 5 plan files and the actual implementation. The executor must verify each item against the live codebase files before writing VERIFICATION.md.

### Phase 5 Plan 01 Truths (Backend Engine)

| # | Must-Have Truth | Pre-Audit Status | Evidence Location |
|---|----------------|-----------------|-------------------|
| 1 | DynamicBufferCalc computes target buffer SoC every 15-min cycle based on PV confidence, price spread, and time of day | CONFIRMED | `dynamic_buffer.py` `step()` method; calls `_compute_target(effective_pv_confidence, price_spread, pv_96, now)` |
| 2 | In observation mode, does NOT call evcc set_buffer_soc() | CONFIRMED | `dynamic_buffer.py` `step()`: `applied = (mode == "live")` then `if applied and target_buffer != old_buffer: self._evcc.set_buffer_soc(target_buffer)` |
| 3 | In live mode, calls evcc set_buffer_soc() only when target changes | CONFIRMED | Same conditional — only triggers when `applied and target_buffer != old_buffer` |
| 4 | Buffer never drops below 10% hard floor, practical minimum 20% | CONFIRMED | `dynamic_buffer.py` constants `HARD_FLOOR_PCT=10`, `PRACTICAL_MIN_PCT=20`; enforced in `_compute_target()` |
| 5 | Observation mode auto-transitions to live after 14 days; deployment_ts survives restarts | CONFIRMED | `_determine_mode()` checks `elapsed >= OBSERVATION_PERIOD_SECONDS`; `_load()` restores `_deployment_ts` from JSON |
| 6 | User can manually activate live early or extend observation via API | CONFIRMED | `activate_live()` and `extend_observation()` public methods |
| 7 | Buffer calculation is skipped when bat-to-EV is active | CONFIRMED | `main.py`: `if buffer_calc is not None and not controller._bat_to_ev_active:` |
| 8 | Every cycle produces a result dict that StateStore broadcasts via SSE | CONFIRMED | `step()` returns dict; `main.py` passes `buffer_result=buffer_result` to `store.update()`; `state_store.py` includes `"buffer": snap.get("buffer_result")` in SSE JSON |

### Phase 5 Plan 01 Artifacts

| Artifact | Min Size | Pre-Audit Status |
|----------|----------|-----------------|
| `dynamic_buffer.py` | 250 lines | CONFIRMED (435 lines) |
| `main.py` contains `buffer_calc` | — | CONFIRMED |
| `state_store.py` contains `buffer_result` | — | CONFIRMED |

### Phase 5 Plan 01 Key Links

| Link | Pre-Audit Status |
|------|-----------------|
| `main.py` → `dynamic_buffer.py` via `buffer_calc.step(` | CONFIRMED |
| `dynamic_buffer.py` → `evcc_client.py` via `_evcc.set_buffer_soc(` | CONFIRMED (in `step()`) |
| `main.py` → `state_store.py` via `buffer_result=buffer_result` | CONFIRMED |
| `state_store.py` → SSE clients via `"buffer"` key | CONFIRMED |

### Phase 5 Plan 02 Truths (Dashboard UI)

These require reading `web/templates/dashboard.html`, `web/static/app.js`, and `web/server.py` during plan execution:

| # | Must-Have Truth | Pre-Audit Status |
|---|----------------|-----------------|
| 1 | Dashboard shows current buffer level and PV confidence in collapsible widget | NEEDS VERIFICATION (web files not read) |
| 2 | Observation mode banner visible with countdown, activate-live, extend buttons | NEEDS VERIFICATION |
| 3 | Buffer history line chart (7-day) | NEEDS VERIFICATION |
| 4 | Expandable event log table with per-event details | NEEDS VERIFICATION |
| 5 | Observation-mode events visually distinguished | NEEDS VERIFICATION |
| 6 | POST /buffer/activate-live and POST /buffer/extend-obs endpoints work | NEEDS VERIFICATION |
| 7 | Buffer section updates live via SSE without page reload | NEEDS VERIFICATION |

**Executor note:** Phase 5 Plan 02 requires reading 3 additional web files during the VERIFICATION.md task. Grep patterns are sufficient for most checks (e.g. `grep -q 'bufferCard' dashboard.html`, `grep -q 'updateBufferSection' app.js`, `grep -q '/buffer/activate-live' server.py`).

---

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| SeasonalLearner accumulates data but output is unused | SeasonalLearner wired into LP objective | Phase 8.1 | LP cost coefficients reflect seasonal error history |
| Phase 5 Dynamic Buffer has no formal verification | VERIFICATION.md documents code evidence for all must_haves | Phase 8.1 | PLAN-03 formally verified, audit trail created |

**Not deprecated:**
- The existing `confidence_factors` dict parameter on `plan()` — seasonal correction is a separate additive term, not a replacement
- `SeasonalLearner.update()` in main.py — already called correctly in Phase 8 Plan 03; this phase only adds the `get_correction_factor()` read path

---

## Open Questions

1. **Unit interpretation of mean_error_eur in the LP cost vector**
   - What we know: `SeasonalLearner.mean_error_eur` = running average of `actual_cost_eur - plan_cost_eur` per 15-min slot. LP `c[t]` = EUR/kWh.
   - What's unclear: The raw EUR error is not directly comparable to EUR/kWh. A slot where 2 kW was charged for 0.25h at 0.25 EUR/kWh would have a max plan cost of ~0.125 EUR. A mean_error of 0.03 EUR for that slot translates to roughly 0.06 EUR/kWh (0.03 / (2*0.25)).
   - Recommendation: Accept the approximation. The safety cap at ±0.05 EUR/kWh limits worst-case impact regardless. Document as "approximate unit alignment" in the helper docstring. This is consistent with the locked decision to "dampen toward neutral."

2. **Should correction factor be surfaced in decision logs?**
   - What we know: Claude has discretion on this. The existing decision log (`decision_log.py`) and main loop log lines (line ~681-685 in main.py) already capture key state.
   - What's unclear: Whether a correction of 0.0 (sparse data) vs 0.02 EUR/kWh meaningfully changes operator understanding.
   - Recommendation: Log the correction value at DEBUG level each cycle (not INFO — it changes rarely and would clutter the log). Add it to the `log("info", ...)` line only if non-zero. This is a simple one-liner addition.

3. **Phase 5 Plan 02 web UI — any gaps?**
   - What we know: Phase 5 Plan 02 was executed successfully (05-02-SUMMARY.md confirmed). Dashboard received the buffer section.
   - What's unclear: Whether all 7 must_have truths from Plan 02 are 100% confirmed in the current web files.
   - Recommendation: Executor must read `dashboard.html`, `app.js`, and `server.py` as part of the VERIFICATION.md task. Grep confirms existence; a brief read of the buffer-related sections confirms correctness.

---

## Sources

### Primary (HIGH confidence)
- `evcc-smartload/rootfs/app/seasonal_learner.py` — full read, confirmed API signature, data model, thread safety
- `evcc-smartload/rootfs/app/optimizer/planner.py` — full read, confirmed LP objective construction, `c[t]` loop, existing `confidence_factors` integration point
- `evcc-smartload/rootfs/app/main.py` — full read, confirmed current `plan()` call site (lines 406-414), `SeasonalLearner.update()` call (lines 603-610), re-plan path (lines 621-633)
- `evcc-smartload/rootfs/app/dynamic_buffer.py` — full read, confirmed all Phase 5 Plan 01 must_haves
- `evcc-smartload/rootfs/app/state_store.py` — full read, confirmed `buffer_result` field and SSE `"buffer"` key
- `.planning/phases/05-dynamic-buffer/05-01-PLAN.md` — full read, extracted all must_haves for audit
- `.planning/phases/05-dynamic-buffer/05-02-PLAN.md` — full read, extracted web must_haves
- `.planning/REQUIREMENTS.md` — confirmed LERN-02 and PLAN-03 status and gap descriptions

### Secondary (MEDIUM confidence)
- `.planning/STATE.md` accumulated decisions — confirm SeasonalLearner: no decay (simple running average), MONTH_TO_SEASON explicit dict
- `.planning/phases/08-residual-rl-and-learning/08-02-SUMMARY.md` and `08-03-SUMMARY.md` — confirm Phase 8 implementation history and what was/wasn't wired

### Tertiary (LOW confidence)
- None — all research was conducted on live codebase files

---

## Metadata

**Confidence breakdown:**
- LERN-02 wiring approach: HIGH — code API is clear, call sites are identified, pattern matches existing `confidence_factors` extension
- PLAN-03 backend verification: HIGH — all 8 Plan 01 must_haves confirmed against live code
- PLAN-03 web verification: MEDIUM — Plan 02 web files not read; known to have been executed successfully but require per-file verification during execution
- Unit interpretation of mean_error_eur: MEDIUM — approximation is defensible and safety-capped
- Safety cap magnitude (±0.05 EUR/kWh): MEDIUM — chosen as Claude's discretion based on typical electricity prices (0.20-0.35 EUR/kWh); 5ct maximum influence is conservative

**Research date:** 2026-02-23
**Valid until:** 2026-03-23 (stable codebase — no fast-moving dependencies)

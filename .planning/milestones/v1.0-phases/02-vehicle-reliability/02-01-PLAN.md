---
phase: 02-vehicle-reliability
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - evcc-smartload/rootfs/app/vehicle_monitor.py
  - evcc-smartload/rootfs/app/main.py
autonomous: true
requirements:
  - RELI-01
  - RELI-02

must_haves:
  truths:
    - "When a vehicle connects to the wallbox, an immediate SoC refresh is triggered within 30 seconds (not waiting for the next 60-minute poll)"
    - "When a vehicle finishes charging (need_kwh < 0.5), the sequencer marks it done within the same decision cycle"
    - "If a second vehicle is waiting, sequencer.plan() activates it on the next cycle after the first is marked done"
  artifacts:
    - path: "evcc-smartload/rootfs/app/vehicle_monitor.py"
      provides: "Connection-event detection with _prev_connected dict and trigger_refresh on connect"
      contains: "_prev_connected"
    - path: "evcc-smartload/rootfs/app/main.py"
      provides: "Sequencer SoC sync every decision cycle before plan()"
      contains: "sequencer.update_soc"
  key_links:
    - from: "evcc-smartload/rootfs/app/vehicle_monitor.py"
      to: "VehicleMonitor.trigger_refresh()"
      via: "connection-event detection in update_from_evcc()"
      pattern: "trigger_refresh"
    - from: "evcc-smartload/rootfs/app/main.py"
      to: "ChargeSequencer.update_soc()"
      via: "inline call in decision loop before sequencer.plan()"
      pattern: "sequencer\\.update_soc"
---

<objective>
Fix vehicle SoC staleness on wallbox connection and charge sequencer slow handoff by wiring existing mechanisms into the correct call sites.

Purpose: RELI-01 ensures the dashboard shows current SoC when a vehicle connects (not a value up to 60 minutes stale). RELI-02 ensures the charge sequencer detects completion and switches to the next waiting vehicle within one decision cycle (under 5 minutes), not up to 15 minutes later.

Output: Modified vehicle_monitor.py with connection-event detection and modified main.py with sequencer SoC sync in the decision loop.
</objective>

<execution_context>
@C:/Users/nicok/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/nicok/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-vehicle-reliability/02-RESEARCH.md
@.planning/phases/01-state-infrastructure/01-01-SUMMARY.md
@evcc-smartload/rootfs/app/vehicle_monitor.py
@evcc-smartload/rootfs/app/main.py
@evcc-smartload/rootfs/app/charge_sequencer.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add connection-event detection to VehicleMonitor.update_from_evcc()</name>
  <files>evcc-smartload/rootfs/app/vehicle_monitor.py</files>
  <action>
Add a `_prev_connected: Dict[str, bool] = {}` instance variable to `VehicleMonitor.__init__()`.

In `update_from_evcc(self, evcc_state: dict)`, after the existing `self._manager.update_from_evcc(evcc_state)` call and the manual SoC override loop, add connection-event detection logic:

1. Get the set of pollable vehicle names via `self._manager.get_pollable_names()` (these are vehicles with API providers like Kia/Renault that support active polling).
2. Iterate `self._manager.get_all_vehicles().items()`.
3. For each vehicle, compare `v.connected_to_wallbox` against `self._prev_connected.get(name, False)`.
4. If the vehicle just connected (`v.connected_to_wallbox and not was_connected`) AND the vehicle is in the pollable set, call `self.trigger_refresh(name)` and log: `log("info", f"VehicleMonitor: {name} connected -- triggering immediate SoC refresh")`.
5. Update `self._prev_connected[name] = v.connected_to_wallbox` for every vehicle regardless.

This is safe because:
- `_prev_connected` is only accessed from `update_from_evcc()` (single-threaded by design -- called from DataCollector._collect_once()).
- `trigger_refresh()` only adds the name to `_refresh_requested` set (guarded by `_lock`). The actual API poll happens in `_poll_loop()` within 30 seconds.
- For evcc-only vehicles (not in pollable set), no refresh is triggered -- evcc already reports their current SoC.

Do NOT call `self._manager.poll_vehicle(name)` directly from `update_from_evcc()` -- polling is I/O and must happen in `_poll_loop()`, not in the synchronous data collection path.
  </action>
  <verify>
Grep for `_prev_connected` in vehicle_monitor.py -- should appear in __init__ and update_from_evcc.
Grep for `trigger_refresh` in vehicle_monitor.py -- should appear in the new connection-event detection block AND the existing trigger_refresh method.
Verify no direct `poll_vehicle` call exists inside `update_from_evcc`.
  </verify>
  <done>
VehicleMonitor.update_from_evcc() detects connection transitions and calls trigger_refresh() for pollable vehicles on connect events. The _prev_connected dict tracks state across calls. No I/O occurs in the synchronous path.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add sequencer SoC sync to main decision loop</name>
  <files>evcc-smartload/rootfs/app/main.py</files>
  <action>
In `main.py`, locate the section of the main `while True:` decision loop where `sequencer.plan()` is called (inside the `if sequencer is not None:` block).

BEFORE the existing `sequencer.plan(...)` call, add a SoC sync loop:

```python
# Sync current SoC into all active sequencer requests every cycle
for vname, vdata in all_vehicles.items():
    if vname in sequencer.requests:
        sequencer.update_soc(vname, vdata.get_effective_soc())
```

This ensures:
- `ChargeRequest.need_kwh` is recalculated every decision cycle based on current SoC.
- When `need_kwh < 0.5`, `update_soc()` sets `status = "done"`.
- On the next `plan()` call, `expire_old_requests()` removes done requests.
- `apply_to_evcc()` then activates the next waiting vehicle.

The variable `all_vehicles` should already exist in the loop scope (from `vehicle_monitor.get_all_vehicles()` or equivalent). If the variable name differs, use whatever the existing code uses to get the current vehicle dict. Read the file first to confirm the exact variable name and insertion point.

Do NOT remove requests for vehicles that are still physically connected but have status "done" -- a vehicle may reach target SoC but remain connected. The existing `expire_old_requests()` handles cleanup after 36 hours.

Do NOT add disconnection detection here -- that is handled by the existing `expire_old_requests()` mechanism. Keep the change minimal: just the update_soc sync loop.
  </action>
  <verify>
Grep for `sequencer.update_soc` in main.py -- should appear at least once (the new sync call).
Grep for `update_soc` in main.py -- confirm it appears before `sequencer.plan`.
Verify the existing `sequencer.plan()` and `sequencer.apply_to_evcc()` calls are still present and unchanged.
  </verify>
  <done>
Every decision cycle, `sequencer.update_soc()` is called for all vehicles with active charge requests, using their current effective SoC. This ensures completion is detected within one cycle, and the sequencer can switch to the next vehicle on the subsequent `plan()` call.
  </done>
</task>

</tasks>

<verification>
1. `_prev_connected` dict exists in VehicleMonitor.__init__()
2. `update_from_evcc()` contains connection-event detection logic with `trigger_refresh()` call
3. `main.py` decision loop contains `sequencer.update_soc()` call BEFORE `sequencer.plan()`
4. No direct `poll_vehicle()` calls inside `update_from_evcc()`
5. No new files created -- all changes are modifications to existing files
6. No new dependencies added
</verification>

<success_criteria>
- VehicleMonitor detects connection events and triggers immediate SoC refresh for pollable vehicles
- Sequencer receives updated SoC every decision cycle, enabling completion detection within one cycle
- Both changes are surgical modifications to existing methods with no new files or dependencies
</success_criteria>

<output>
After completion, create `.planning/phases/02-vehicle-reliability/02-01-SUMMARY.md`
</output>
